<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <title>SkySpace</title>

    <link href="../../formatting/pandoc.css" rel="stylesheet">
    <link href="../../formatting/envbox.css" rel="stylesheet">
    <link href="../../formatting/bars.css" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.4.1/jquery.easing.min.js" integrity="sha256-H3cjtrm/ztDeuhCN9I4yh4iN2Ybx/y1RM7rMmAesA0k=" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>

  </head>
  <body>
    <div class="wrapper">
      <nav id="sidebar">
        <div id="sidebar-content">
          <div class="sidebar-header">
            <h3>SkySpace</h3>
          </div>
          <ul class="list-unstyled components">
            <li> <a href="https://awestover.github.io">awestover.github.io</a> </li>
            <li> <a href="../index.html">Home</a> </li>
            <li> <a href="../about.html">About</a> </li>
            <li> <a href="../topics.html">Topics</a> </li>
            <hr>
            <div id="toc">
            <li> <a href="#introduction
" class="js-scroll-trigger">Introduction
</a> </li>
<li> <a href="#backlog-bounds
" class="js-scroll-trigger">Backlog bounds
</a> </li>
<li> <a href="#oracles
" class="js-scroll-trigger">Oracles
</a> </li>
            </div>
          </ul>
          <div id="canvas-parent"> </div>
        </div>
      </nav>

      <div id="content"> 
      <h1 id="the-bamboo-cutting-robot-panda-gardener">The Bamboo Cutting Robot Panda Gardener</h1>
<p><img src="src/images/panda1.png" alt="image of oracle" /> <img src="src/images/panda2.png" alt="image of oracle" /></p>
<h1 id="introduction">Introduction</h1>
<p>Everything I learned about this game comes from the following article: <a href="https://arxiv.org/abs/2005.00168">Bilò, Davide, et al. “Cutting Bamboo Down to Size.” arXiv preprint arXiv:2005.00168 (2020).</a>. This is an awesome article! I highly recommend reading it. Obviously they do a better job explaining this topic than me. I’m pretty much just writing this so that I can understand it. The one reason why maybe this is a good article for you to read is that I was pretty unfamiliar with some of the ideas from the article before reading it, so I spell out a few things more explicitely (e.g. the cool data structures used in their oracle) than the article. I’m not the type of person that likes making things longer but whatever. I dunno. lol. if I haven’t convinced you that there is no reason for this blog post to exist, then read and enjoy!</p>
<p>The other day I was reading about robot panda gardeners. Specifically here is the problem:</p>
<div class="defn envbox">
<p><strong>Definition.</strong> <strong>Growing Bamboo problem:</strong></p>
<p>You just bought a nice house on a lake. Oh no! There are <span class="math inline">\(n\)</span> bamboo stalks <span class="math inline">\(b_1, \ldots, b_n\)</span> with growth rates <span class="math inline">\(h_1, \ldots, h_n\)</span> satisfying <span class="math inline">\(\sum h_i = 1\)</span> and <span class="math inline">\(h_1 \ge \cdots \ge h_n\)</span> that are growing and obscuring your view of the lake! In particular, the height of the tallest bamboo stalk determines your ability to see the lake. The height of the tallest bamboo is called the <strong>backlog</strong> of the set of bamboos. To fix this terrible problem you are going to program a robotic panda gardener. Every day the height of bamboo <span class="math inline">\(i\)</span> will increase by <span class="math inline">\(h_i\)</span>. Then, at the end of the day, the robotic panda gardener can choose <span class="math inline">\(1\)</span> bamboo to cut– that is, to reduce its height to <span class="math inline">\(0\)</span>.</p>
</div>
<p>So the question is, how do we program the panda to minimize the largest height the bamboo ever achieves? And of course, what is the largest height that the bamboo will ever achieve given our strategy?</p>
<p>This game is a restricted version of a game that I’ve been analyzing: <strong>the cup game</strong>. The cup game is basically like this except that the growth rates can change. And actually I’ve been looking at a variant of the cup game where the amount of growth sums to <span class="math inline">\(1 \le p \le n\)</span> and where the gardener (called the <strong>emptier</strong> in the cup game) can cut <span class="math inline">\(p\)</span> bamboos. In fact I’ve been looking at a variant of this <span class="math inline">\(p\)</span>-processor cup game called the variable-processor cup game in which <span class="math inline">\(p\)</span> is allowed to change. Anyways, in the single-processor cup game on <span class="math inline">\(n\)</span> cups backlog never exceeds <span class="math inline">\(O(\log n)\)</span> with a greedy emptying strategy, and backlog can be made <span class="math inline">\(\Omega(\log n)\)</span> with an appropriate filling strategy. In the bamboo cutting game though, the restriction that growth rate can’t change makes it possible to achieve <span class="math inline">\(O(1)\)</span> backlog.</p>
<p>Before talking about strategies for keeping backlog low, lets get a lower bound. Say the growth rates are <span class="math inline">\(1-\epsilon, \epsilon\)</span> for some <span class="math inline">\(\epsilon &gt;0\)</span>. Then on any day when the panda cuts <span class="math inline">\(b_2\)</span> (the bamboo with growth rate <span class="math inline">\(h_2 = \epsilon\)</span>) the height of the other bamboo will grow to <span class="math inline">\(2-2\epsilon\)</span> by the end of the next day. Hence <span class="math inline">\(2\)</span> is a lower bound on backlog: the best upper bound we can hope for is “there exists a panda that never lets backlog exceed <span class="math inline">\(2\)</span>”.</p>
<p>There are two really natural gardening strategies: <strong>Reduce-Max</strong> and <strong>Reduce-Fastest<span class="math inline">\((x)\)</span></strong>. Here’s what they do:</p>
<div class="defn envbox">
<p><strong>Definition.</strong> Reduce-Max: cut the tallest bamboo</p>
</div>
<div class="defn envbox">
<p><strong>Definition.</strong> Reduce-Fastest<span class="math inline">\((x)\)</span>: Cut the fastest growing bamboo with height above <span class="math inline">\(x\)</span>.</p>
</div>
<p>To start, Davide et al. analyze these strategies. In particular they show that Reduce-Max never lets backlog exceed <span class="math inline">\(9\)</span>, and Reduce-Fastest<span class="math inline">\((1+1/\sqrt{5})\)</span> never lets backlog exceed <span class="math inline">\(1+\phi &lt; 2.62\)</span>. After doing this, they provide algorithms for constructing <strong>cutting oracles</strong>. A cutting oracle tells you what bamboo to cut. They make cutting oracles for Reduce-Max, Reduce-Fastest<span class="math inline">\((x)\)</span> and then they make a cutting oracle that never lets backlog exceed <span class="math inline">\(2\)</span>. Yay! And the cutting oracles have great query-time-complexity, build-time-complexity, space-complexity, and stuff.</p>
<h1 id="backlog-bounds">Backlog bounds</h1>
<h3 id="reduce-max">Reduce-Max</h3>
<p>We partition the bamboo’s into sets based on the powers of <span class="math inline">\(1/2\)</span> that their growth rates fall between, and then inductively prove a set of invariants.</p>
<p>Bamboo <span class="math inline">\(b_i\)</span> is said to be of <strong>level</strong> <span class="math inline">\(j\)</span> if <span class="math inline">\(2^{-j} \le h_i &lt; 2^{-(j-1)}.\)</span> Let <span class="math inline">\(K\)</span> be the level of <span class="math inline">\(b_n\)</span>. Let <span class="math inline">\(L_j\)</span> for <span class="math inline">\(j \in [K]\)</span> denote the set of all bamboos of level <span class="math inline">\(j\)</span>. Define <span class="math inline">\(\sigma(j)\)</span> for <span class="math inline">\(j \in [K]\)</span> to be the maximum height ever reached by any bamboo of level <span class="math inline">\(k \ge j\)</span>, and define <span class="math inline">\(\sigma(K+1) = 0.\)</span> Then we will show:</p>
<div class="lem envbox">
<p><strong>Lemma.</strong> <span class="math display">\[\sigma(j) \le \max\{3, \sigma(j+1)\} + \frac{3}{2^j} \sum_{k=1}^j |L_k|.\]</span></p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> Fix some level <span class="math inline">\(j\)</span>. Let <span class="math inline">\(d_1\)</span> be a day when a bamboo <span class="math inline">\(i\)</span> of level <span class="math inline">\(j\)</span> achieves height <span class="math inline">\(\sigma(j)\)</span>. (ok, digression, this is how the authors start their proof in the paper, but as a student of real analysis this step feels bad to me. Like what if, I said to myself, <span class="math inline">\(\sigma(j)\)</span> is never achieved. they really define it as a supremum not a maximum. But then I was like ooooh, ahhhh. I’ll tell you why later :). But for now, rest assured that this is really a valid step.)</p>
<p>Let <span class="math inline">\(d_0\)</span> be the most recent day prior to <span class="math inline">\(d_1\)</span> when either (a) a bamboo <span class="math inline">\(b_\ell\)</span> of level greater than <span class="math inline">\(j\)</span> was cut, or (b) a bamboo <span class="math inline">\(b_\ell\)</span> of height less than <span class="math inline">\(3\)</span> was cut.</p>
<p>Because the panda is following Reduce-Max <span class="math inline">\(b_i\)</span>’s height at <span class="math inline">\(d_1\)</span>, and consequently <span class="math inline">\(\sigma(j)\)</span> (by definition of <span class="math inline">\(d_1\)</span> to be a day when <span class="math inline">\(b_i\)</span> achieves height <span class="math inline">\(\sigma(j)\)</span>) are bounded above by <span class="math display">\[\max\{3, \sigma(j+1)\} + h_i(d_1-d_0).\]</span> That is, the height of <span class="math inline">\(b_i\)</span> on day <span class="math inline">\(d_0\)</span> was less than whatever bamboo was cut on day <span class="math inline">\(d_0\)</span>, and the height of bamboo <span class="math inline">\(b_i\)</span> has grown by at most <span class="math inline">\(h_i(d_1-d_0)\)</span> since then till day <span class="math inline">\(d_1\)</span>. It remains to bound <span class="math inline">\(d_1-d_0\)</span>.</p>
<p>By definition of <span class="math inline">\(d_0\)</span> for each day <span class="math inline">\(t\in [d_0+1, d_1]\)</span> <strong>both</strong> (a) the bamboo cut on day <span class="math inline">\(t\)</span> has level at most <span class="math inline">\(j\)</span>, and (b) the bamboo cut on day <span class="math inline">\(t\)</span> has height at least <span class="math inline">\(3\)</span>.</p>
<p>We call a cut of bamboo <span class="math inline">\(b_\ell\)</span> on a day <span class="math inline">\(t \in [d_0+1, d_1]\)</span> a <strong>first-cut</strong> if it is the first day in <span class="math inline">\([d_0+1, d_t]\)</span> where bamboo <span class="math inline">\(b_\ell\)</span> has been cut. On the other hand, a cut of bamboo <span class="math inline">\(b_\ell\)</span> is a <strong>repeated cut</strong> if it is not a first-cut of <span class="math inline">\(b_\ell\)</span>.</p>
<p>Note that repeated cuts are cutting bamboo growth that happened completely during <span class="math inline">\([d_0+1, d_1]\)</span>. The total amount of bamboo growth that happened in this interval is of course <span class="math inline">\(d_1-d_0\)</span> (as <span class="math inline">\(\sum h_i = 1\)</span>). Since each cut is cutting a bamboo of height at least <span class="math inline">\(3\)</span> the total number of repeated cuts can’t exceed <span class="math inline">\(\frac{1}{3}(d_1-d_0)\)</span>.</p>
<p>On the other hand, the number of first cuts can’t be more than <span class="math inline">\(\sum_{k\le j} |L_k|\)</span> because all the cuts must be cuts of bamboos of levels <span class="math inline">\(k\le j\)</span>. Thus, the total number of cuts <span class="math inline">\(d_1-d_0\)</span> is the number of first cuts plus the number of repeated cuts, so <span class="math display">\[d_1-d_0 \le \frac{1}{3}(d_1-d_0) + \sum_{k\le j} |L_k|.\]</span> Manipulating this we have <span class="math display">\[d_1-d_0 \le \frac{3}{2}\sum_{k\le j} |L_k|.\]</span></p>
<p>Recall that <span class="math inline">\(h_i &lt; \frac{2}{2^j}\)</span> by definition of it being level <span class="math inline">\(j\)</span>.</p>
<p>Combining our results we have: <span class="math display">\[\sigma(j) \le \max\{3, \sigma(j+1)\} + \frac{2}{2^j}\frac{3}{2}\sum_{k\le j} |L_k|\]</span> as desired.</p>
</div>
<p>Now to complete the proof we use this Lemma a bunch of times:</p>
<p><span class="math display">\[\sigma(1) \le \sigma(2) + \frac{3}{2^1}\sum_{k\le 1} |L_k|\]</span> <span class="math display">\[\le \sigma(3) + \sum_{j=1}^2 \frac{3}{2^j}\sum_{k\le j}|L_k|\]</span> <span class="math display">\[\le \sigma(4) + \sum_{j=1}^3 \frac{3}{2^j}\sum_{k\le j} |L_k|\]</span> <span class="math display">\[\cdots \le \max\{3, \sigma(K+1)\} + \sum_{j=1}^K \frac{3}{2^j}\sum_{k\le j} |L_k|.\]</span> That is, <span class="math display">\[\sigma(1) \le 3+ 3\sum_{j=1}^K \frac{3}{2^j} \sum_{k \le j}|L_k|.\]</span> Consider how much an arbitrary bamboo <span class="math inline">\(b_i\)</span> of level <span class="math inline">\(s\)</span> counts towards this sum. It counts this much: <span class="math display">\[\sum_{j=s}^K \frac{3}{2^j}.\]</span> The geometric series <span class="math display">\[\sum_{j=s}^\infty \frac{3}{2^j} \le \frac{3}{2^{j-1}} \le 6h_i\]</span> upper bounds the contribution.</p>
<p>Thus, summing for all bamboos we have <span class="math display">\[\sigma(1) \le 3 + \sum 6h_i.\]</span></p>
<p>Since the <span class="math inline">\(h_i\)</span> sum to <span class="math inline">\(1\)</span> we then have: <span class="math display">\[\sigma(1) \le 9.\]</span></p>
<h3 id="reduce-fastest">Reduce-Fastest</h3>
<p>See their paper. It’s a bit messy.</p>
<div class="cor envbox">
<p><strong>Corollary.</strong> Reduce-Fastest<span class="math inline">\((1+1/\sqrt{5})\)</span> never lets backlog exceed <span class="math inline">\(1+\phi &lt; 2.62\)</span>.</p>
</div>
<h1 id="oracles">Oracles</h1>
<h3 id="why-do-we-want-an-oracle">Why do we want an Oracle?</h3>
<p>ok so when they first started talking about oracles I was pretty confuzed: “why do we need an oracle, Reduce-Max is literally so ez to implement.” But then I realized: “oh crap, the naive implementation of Reduce-Max (loop over the bamboos to find largest) has running-time <span class="math inline">\(O(n)\)</span>”. Their Oracle is going to have much better running time by utilizing some data structures that support the operation “cut a bamboo” and “find the next bamboo to cut”.</p>
<p>After thinking about this for a little bit longer I was still a bit uneasy. I was thinking, ok this is nice and all, but it seems kind of crumby to have to have an Oracle going forever. This perpetual cycle is gonna repeat, can’t we just make a little lookup table? Ah! But that’s when I realized. You can make a look up table sure, but it’s going to be big, not small. In particular, Let’s consider the set of possible bamboo states for something like Reduce-Max. It seems kind of like any bamboo <span class="math inline">\(b_i\)</span> should be able to get to height <span class="math inline">\(h_i \cdot r_i\)</span> for any <span class="math inline">\(r_i \le 1/h_i\)</span> or something. Formalizing this, here’s an example of a bamboo garden where this is pretty much achieved: <span class="math display">\[1/2, 1/4, 1/8, \ldots, 1/2^{n-1}, 1/2^{n-1}.\]</span> Note that a bamboo has to get up to height <span class="math inline">\(1/2\)</span> to be cut by Reduce-Max, so this means that bamboo <span class="math inline">\(b_i\)</span> is going to get to grow for like <span class="math inline">\(2^{i-1}\)</span> rounds here, as <span class="math inline">\(h_i =1/2^i\)</span> for <span class="math inline">\(i &lt; n\)</span>. But jeeeez that’s a lot of states! In particular it’s like <span class="math display">\[\prod_{i=1}^n 2^{i-1} = 2^{\Omega(n^2)}\]</span> states. Crap: super exponential space-complexity! That’s no good. The not-so-innocent-looking expression <span class="math inline">\(\prod_{i=1}^n \frac{1}{h_i}\)</span> should strike fear into your heart.</p>
<p>Anyways, I hope by now that when you see the Oracle’s running-time and space-complexity guarantees you’ll be duly impressed (unlike me on my first read of the paper!).</p>
<h3 id="reduce-fastestx">Reduce-Fastest<span class="math inline">\((x)\)</span></h3>
<div class="thm envbox">
<p><strong>Theorem.</strong> There is a cutting-oracle implementing Reduce-Fastest<span class="math inline">\((x)\)</span> that uses <span class="math inline">\(O(n)\)</span> space, can be built in <span class="math inline">\(O(n\log n)\)</span> time, and can report the next bamboo in <span class="math inline">\(O(\log n)\)</span> time.</p>
</div>
<p>The crux of their oracle algorithm is a data structure called a <strong>priority search tree</strong>. My best description of this is “if a binary search tree and a priority queue had a child it would be a priority search tree”. um ok. anywaaays. Here’s what a priority search tree is:</p>
<div class="defn envbox">
<p><strong>Definition.</strong> Say you have a set of data <span class="math inline">\(\{(x_1, p_1), \ldots, (x_n, p_n)\}.\)</span> We call the <span class="math inline">\(p_i\)</span>’s <strong>priorities</strong> and we call the <span class="math inline">\(x_i\)</span>’s <strong>values</strong>.</p>
<p>The priority search tree <span class="math inline">\(T\)</span> associated with this data is a binary tree satisfying the following properties:</p>
<p>For any node <span class="math inline">\(v = (x, p)\)</span></p>
<ul>
<li>all descendants of <span class="math inline">\(v\)</span> have priority lower than <span class="math inline">\(p\)</span>.</li>
</ul>
<p>If you compute the median of the values of all descendants of <span class="math inline">\(v\)</span> then - all left descendants of <span class="math inline">\(v\)</span> have value less than this median. - all right descendants of <span class="math inline">\(v\)</span> have value greater than that median.</p>
</div>
<p>It’s a binary tree, and it’s obviously balanced by the median thing, so its depth is <span class="math inline">\(O(\log n)\)</span> and you can store it in an a array with space <span class="math inline">\(O(n)\)</span> and as long as insertion is <span class="math inline">\(O(\log n)\)</span> (which it is, I’ll describe insertion in a second) you can build a priority search tree in time <span class="math inline">\(O(n \log n)\)</span>.</p>
<p>ok, so now let’s talk about how to do all the opperations that you need to do.</p>
<p>So, imagine that you wanted to query for a certain value. Then it’s just like a binary search tree. <strong>Note: I guess you have to store the medians.</strong></p>
<p>OK now let me talk about the application to the specific problem of a Reduce-Fastest<span class="math inline">\((x)\)</span> oracle.</p>
<p>So the (dynamic) data that is going to be stored in the priority search tree is <span class="math display">\[\{(d_1, 1), \ldots, (d_n, n)\}\]</span> where <span class="math inline">\(d_i\)</span> is the next day on which bamboo <span class="math inline">\(b_i\)</span> will have height at least <span class="math inline">\(x\)</span>. Note that this is going to be updated every day.</p>
<p>The queries that it needs to support are:</p>
<ul>
<li><span class="math inline">\(\mathbf{\text{MinIReadyBeforeDayD}(T, D)}\)</span>: return the minimum <span class="math inline">\(i\)</span> such that <span class="math inline">\(d_i \le D\)</span>. (note: if you’re following along with the paper you will notice that they have a typo about this! don’t worry I have lots of typos too I bet.)</li>
<li><strong>GetD</strong><span class="math inline">\((T, i)\)</span>: returns <span class="math inline">\(d_i\)</span> i.e. finds the node <span class="math inline">\((d_i, i)\)</span>.</li>
</ul>
<p>It can support them in <span class="math inline">\(O(\log n)\)</span> time. Great!</p>
<p>After cutting the bamboo <span class="math inline">\(b_i\)</span> we need to update the tree. I think the way to do this is to delete it, sift, and then insert it and sift again. (sifting is that thing you do with heaps).</p>
<p>Ah, but we’re not quite done, because there is this subtle issue: throughout this we have been implicity assuming that <span class="math inline">\(d_i \le O(1)\)</span>. But the oracle is going to continue <strong>forever</strong>! So this is clearly not a reasonable assumption. To solve this problem they divide the days up into intervals of <span class="math inline">\(I\)</span> days, and then store <span class="math inline">\(2\)</span> trees: one for the current interval and one for the next interval.</p>
<p>Then within each tree they don’t store <span class="math inline">\(d_i\)</span> but rather <span class="math inline">\(\delta_i = d_i - nj\)</span> for the <span class="math inline">\(j\)</span>-th interval which consists of days <span class="math inline">\(\{nj, nj+1, \ldots, n(j+1)-1\}.\)</span></p>
<p>Say that the two trees you were maintaining are called <span class="math inline">\(T_1, T_2\)</span>. At the end of an interval you just are like <span class="math inline">\(T_1 \gets T_2\)</span> and <span class="math inline">\(T_2 \gets T_2\)</span> Except reduce the numbers in <span class="math inline">\(T_2\)</span> by <span class="math inline">\(n\)</span>.</p>
<p>This aught to do the trick.</p>
<p>At this point the theorm should be pretty clear, it’s basically just saying “priority search trees” have <span class="math inline">\(O(n)\)</span> space-complexity and can be queried in <span class="math inline">\(O(\log n)\)</span> time!</p>
<h3 id="reduce-max-1">Reduce-Max</h3>
<p>Bunch of lines. Upper envelope thing. See their paper.</p>
<h3 id="tree-backlog-2">Tree: backlog 2</h3>
<p>Now they introduce a new algorithm which prevents backlog from ever exceeding <span class="math inline">\(2\)</span>: recall that this is the best possible backlog bound!</p>
<p>Here’s their full theorem:</p>
<div class="thm envbox">
<p><strong>Theorem.</strong> There exists a cutting oracle that never lets backlog exceed <span class="math inline">\(2\)</span>, uses <span class="math inline">\(O(n)\)</span> space, can be built in <span class="math inline">\(O(n \log n)\)</span> time, and can report the bamboo to trim in <span class="math inline">\(O(\log n)\)</span> amortized time.</p>
</div>
<p>The algorithm they made for this, which they call <strong>Tree</strong>, is an amazing example of the famous problem solving principle &gt; “To solve a hard problem, first solve a simpler problem, then prove that your original problem can be reduced to the simpler problem.” -Alek</p>
<p>So first round down all the <span class="math inline">\(h_i\)</span>’s to powers of <span class="math inline">\(1/2\)</span>. But they want to preserve the summing-to-<span class="math inline">\(1\)</span> property, so it’s slightly more complicated than this. The backlog in the real game is at most double the backlog in this other game, since the growth rates were at most doubled.</p>
<p>They prove a bound of <span class="math inline">\(1\)</span> on backlog in this new game where the growth rates are nice.</p>
<p>To analyze this new game, they next look at a sub-case(even simpler problem!!!) which they call <strong>regular growth rates</strong>. This is where the growth rates are <span class="math display">\[1/2, 1/4, 1/8, \ldots, 1/2^{n-1}, 1/2^{n-1}.\]</span></p>
<p>Consider the binary representation of <span class="math inline">\(D\)</span> with <span class="math inline">\(n-1\)</span> digits (so like take <span class="math inline">\(D \mod 2^{n-1}\)</span> and do zero-padding on the left). In this case they have a really simple rule to decide what to cut: on day <span class="math inline">\(D\)</span> cut bamboo <span class="math inline">\(b_i\)</span> if the right-most (i.e. least-significant) <span class="math inline">\(0\)</span> in <span class="math inline">\(D\)</span> is the <span class="math inline">\(i\)</span>-th least-significant bit of <span class="math inline">\(D\)</span>; if there are no <span class="math inline">\(0\)</span>’s in <span class="math inline">\(D\)</span> then cut <span class="math inline">\(b_n\)</span>. Let’s look at this a little bit (ahhhh get it. oh gross puns):</p>
<p>Let’s run through the cutting schedule with <span class="math inline">\(n=5\)</span></p>
<ul>
<li><span class="math inline">\(0000 \implies\)</span> cut <span class="math inline">\(b_1\)</span></li>
<li><span class="math inline">\(0001 \implies\)</span> cut <span class="math inline">\(b_2\)</span></li>
<li><span class="math inline">\(0010 \implies\)</span> cut <span class="math inline">\(b_1\)</span></li>
<li><span class="math inline">\(0011 \implies\)</span> cut <span class="math inline">\(b_3\)</span></li>
<li><span class="math inline">\(0100 \implies\)</span> cut <span class="math inline">\(b_1\)</span></li>
<li><span class="math inline">\(0101 \implies\)</span> cut <span class="math inline">\(b_2\)</span></li>
<li><span class="math inline">\(0110 \implies\)</span> cut <span class="math inline">\(b_1\)</span></li>
<li><span class="math inline">\(0111 \implies\)</span> cut <span class="math inline">\(b_4\)</span></li>
<li><span class="math inline">\(1000 \implies\)</span> cut <span class="math inline">\(b_1\)</span></li>
<li><span class="math inline">\(1001 \implies\)</span> cut <span class="math inline">\(b_2\)</span></li>
<li><span class="math inline">\(1010 \implies\)</span> cut <span class="math inline">\(b_1\)</span></li>
<li><span class="math inline">\(1011 \implies\)</span> cut <span class="math inline">\(b_3\)</span></li>
<li><span class="math inline">\(1100 \implies\)</span> cut <span class="math inline">\(b_1\)</span></li>
<li><span class="math inline">\(1101 \implies\)</span> cut <span class="math inline">\(b_2\)</span></li>
<li><span class="math inline">\(1110 \implies\)</span> cut <span class="math inline">\(b_1\)</span></li>
<li><span class="math inline">\(1111 \implies\)</span> cut <span class="math inline">\(b_5\)</span></li>
<li>and then it just repeats</li>
</ul>
<p>So there are some things that you should have observed. The gap between days when we cut <span class="math inline">\(b_1\)</span> is <span class="math inline">\(2\)</span>, the gap between days when we cut <span class="math inline">\(b_2\)</span> is <span class="math inline">\(4\)</span>, the gap for <span class="math inline">\(b_3\)</span> is <span class="math inline">\(8\)</span>, <span class="math inline">\(\ldots\)</span>, the gap for <span class="math inline">\(b_{n-1}\)</span> is <span class="math inline">\(2^{n-1}\)</span>. And of course the gap for <span class="math inline">\(b_n\)</span> is also <span class="math inline">\(2^{n-1}\)</span>. This ensures that bamboo <span class="math inline">\(b_i\)</span> never grows above <span class="math inline">\(1\)</span>.</p>
<p>Another thing that you should note is that you can increment a binary counter in <span class="math inline">\(O(1)\)</span> <strong>ammortized time</strong>. I guess this just means average time. Basically this is because <span class="math display">\[\frac{1}{2}1 + \frac{1}{4}2 + \frac{1}{8}3 + \frac{1}{16} 4 + \cdots  \le O(1).\]</span> COol.</p>
<p>OK, so that’s super simple, but what about the <strong>real</strong> game? First let’s do the powers of <span class="math inline">\(1/2\)</span> one still. So here’s the idea: they define a <strong>virtual bamboo</strong> to be a bunch of bamboo lumped together. Then by collapsing the original bamboo forest into an appropraite set of virtual bamboos they can get a really nice set of virtual bamboos.</p>
<p>Then you globally and internally inside the virtual bamboos do the super simple strategy.</p>
<p>yay!</p>
<p>Note: it’s actually really technically interesting how they make the virtual bamboos with their merge operations. I don’t fully understand the proof that the merge tree thing has depth <span class="math inline">\(O(\log n)\)</span> (although I do get why it has depth less than <span class="math inline">\(O(n)\)</span>, and it feels vaguely intuitive to me.)</p>
<p>Now, notice that in restricting the <span class="math inline">\(h_i\)</span>’s to be powers of <span class="math inline">\(1/2\)</span> the <span class="math inline">\(h_i\)</span>’s were changed by at most a factor of <span class="math inline">\(2\)</span>. So if you just pretend like you’re playing with the fake growth rates, then the real height,s and hence the real backlog, is no more than a factor of <span class="math inline">\(2\)</span> larger than you think it is.</p>
<h1 id="the-end">The End</h1>
<p>I’ve had a blast reading this paper. I have to say the robot pandas really made me happy, what a fun way to phrase the work scheduling problem.</p>
<p>The upper bound proofs are very classic combinatorics: “inductively prove a set of invariants”. I really love the forced tradeoffs that give the inequalities. I’m always happy to see cool data structures and really liked hearing about priority search queues. The final oracle for achieving backlog 2 is such a cool example of solving a simple problem and reducing the harder problem to the simple problem. SO COOL!</p>
<p>In the future I’ll try to have more robot panda gardeners in my own work, and in my own life. I’ll also try to do some mroe blog posts about cool papers.</p>

      </div>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full"></script>
    <script src="../../formatting/scrolling-nav.js"></script>

    <script charset="utf-8">
        var pres = document.querySelectorAll("pre>code");
        for (var i = 0; i < pres.length; i++) {
            hljs.highlightBlock(pres[i]);
        }
    </script>

  </body>
</html>
