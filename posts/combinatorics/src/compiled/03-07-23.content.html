<h1 id="uuu-dyck-path">{UUU dyck path}</h1>
<p>Let <span class="math inline">\(C_{n}=\frac{1}{n+1}\binom{2n}{n}\)</span> denote the <span class="math inline">\(n\)</span>-th Catalan number. We have seen that <span class="math inline">\(C_n\)</span> counts the number of Dyck paths with <span class="math inline">\(n\)</span> up steps and <span class="math inline">\(n\)</span> down steps. Let <span class="math inline">\(A_{n}\)</span> denote the number of Dyck paths with <span class="math inline">\(n\)</span> up steps and <span class="math inline">\(n\)</span> down steps where the first <span class="math inline">\(3\)</span> steps are up steps. The goal of this problem is to determine <span class="math inline">\(A_{n}.\)</span></p>
<div class="prop envbox">
<p><strong>Proposition.</strong> <span class="math inline">\(A_{n}=C_n-2C_{n-1}\)</span></p>
</div>
<h1 id="bijection-of-trees">{bijection of trees}</h1>
<p>We showed in class that the number of plane trees with <span class="math inline">\(n+1\)</span> vertices is <span class="math inline">\(C_n\)</span>, i.e. the number of Dyck paths with <span class="math inline">\(n\)</span> up and <span class="math inline">\(n\)</span> down steps. The bijection is straightforward: take a depth-first traversal of a plane tree with <span class="math inline">\(n+1\)</span> vertices (and thus <span class="math inline">\(n\)</span> edges); each step away from the root is turned into an up step in the Dyck path, and each step towards the root becomes a down step. The process is clearly invertable: we can generate the tree from it’s depth-first traversal sequence. To count Dyck paths, we reasoned as follows in lecture: let <span class="math inline">\(2k \in \{2,4,6,\ldots, 2n\}\)</span> be the first time that the Dyck path comes back down to height <span class="math inline">\(0\)</span>. Then, the Dyck path is clearly composed of an up step, followed by a Dyck path of length <span class="math inline">\(2k-2\)</span> shifted up <span class="math inline">\(1\)</span> unit followed by a down step. After hitting height <span class="math inline">\(0\)</span> we can do another Dyck path now of length <span class="math inline">\(2n-2k.\)</span> This gives the well-known recurrence <span class="math display">\[C_n = \sum_{k=1}^n C_{k-1}C_{n-k} =
\sum_{k=0}^{n-1}C_{k}C_{n-k-1}.\]</span> But it also gives us more than just a recurrence: it gives us a way of thinking about how Dyck paths are recursively composed of smaller shifted Dyck paths.</p>
<p>Now we will show that binary trees with <span class="math inline">\(n\)</span> vertices exhibit the same recursive structure. One consequence of this is that the numbers <span class="math inline">\(B_n\)</span>, which we use to denote the number of binary trees on <span class="math inline">\(n\)</span> vertices, obeys the same recurrence as <span class="math inline">\(C_n\)</span>. But more interestingly, the fact that both objects have the same recursive structure allows us to form an algorithm that converts between the two objects, i.e. a bijection. We can see that a binary tree will have a root, and then some number <span class="math inline">\(k\in 0,1,\ldots, n-1\)</span> of nodes to its left, with the remaining <span class="math inline">\(n-k-1\)</span> of nodes being to the right of the root (i.e. descendants via its right child, if there is a right child). In other words, <span class="math display">\[B_n = \sum_{k=0}^{n-1} B_k B_{n-k-1}.\]</span> Now, checking / defining that <span class="math inline">\(B_0=C_0 = 1, B_1=C_1=1\)</span> suffices to prove that the sequences are equal, but doesn’t quite give us an understanding of why they are equal.</p>
<p>Now we exhibit a bijection between binary trees and dyck paths; combined with our bijection between dyck paths and plane binary trees this constitutes a bijective proof that <span class="math inline">\(B_n = C_n\)</span>.</p>
<p>Consider a binary tree; we associate a Dyck path with it. If the root has no left children, the associated Dyck path starts with up, down and then the remainder of the Dyck path is the Dyck path associated with the right sub-tree. If the root has left children, the associated Dyck path will be up, then the Dyck path for the left sub-tree, and finally down, and then followed by the right sub-tree’s associated Dyck tree (if the right sub-tree is non-empty). The conversion backwards is similarly straightforward. If we consider a segment with length <span class="math inline">\(2k+2\)</span> of a Dyck path that starts and ends at height <span class="math inline">\(0\)</span> but does not touch height <span class="math inline">\(0\)</span> in the middle, then we recursively use this segement to construct the left sub-tree of the root in the associated tree. In particualr, if <span class="math inline">\(k=0\)</span> this corresponds to up down. This is better described via a picture: <img src="src/images/ink_img004.png" alt="ink" /></p>
<h1 id="section">{3}</h1>
<p>The bijection is as follows: draw the non-crossing set partition in a circle as a set of non-crossing polygons by connecting the points in the same parts of the partition. Now, put a “dual vertex” on the midpoint of each edge of the original diagram. Connect two dual vertices iff doing so is possible without crossing the original diagram’s polygons. If the original diagram had <span class="math inline">\(k\)</span> sets in the partition, then this new diagram will have <span class="math inline">\(n-k+1\)</span>. And, if we apply the transformation again then we get back the original set partition, so the transformation is a bijection of non-crossing set partitions with <span class="math inline">\(k\)</span> blocks to those with <span class="math inline">\(n-k+1\)</span> blocks.</p>
<figure>
<img src="src/images/ink_img006.png" alt="" /><figcaption>ink</figcaption>
</figure>
<h1 id="modmaj-modinv">{modmaj, modinv}</h1>
<p>It is well known that major index is equidistributed with number of inversions. Thus, we may consider instead  the number of permutations with a number of inversions which has some <span class="math inline">\(k\)</span> under <span class="math inline">\(\mod n\)</span>. Consider a random permutation. It will have some number of inversions contributed by pairs of elements in <span class="math inline">\([n-1]\)</span>. Then, there will be some inversions which are inversions with element <span class="math inline">\(n\)</span>. If we are considering a random permutation then <span class="math inline">\(n\)</span> is equally likely to be inverted with any number of other elements. If the number of inversions was some number <span class="math inline">\(k\)</span> just counting elements pairs in <span class="math inline">\([n-1]\)</span>, then we see that it will be equally likely to be any value <span class="math inline">\(k+0,k+1,k+2,\ldots, k+n-1\)</span> after considering the last one. But of course, this means that it is uniformly randomly distributed on <span class="math inline">\([n]\)</span> if we consider it <span class="math inline">\(\mod n\)</span>. This is equivalent to the desired result because the probability of having modinv of <span class="math inline">\(k\)</span> is simply the number of permutations with modinv <span class="math inline">\(k\)</span> divided by <span class="math inline">\(n!\)</span>.</p>
In fact, Major index has this same property: that randomly adding <span class="math inline">\(n\)</span> into a permutation of length <span class="math inline">\(n-1\)</span> increases the major index by a uniformly random value in <span class="math inline">\([n]-1\)</span>. Thus, the following Proposition more directly establishes the result desired in the problem.
<div class="prop envbox">
<p><strong>Proposition.</strong>  If we consider each possible way to form <span class="math inline">\(\pi&#39;\)</span> from <span class="math inline">\(\pi\in  S_{n-1}\)</span> by inserting <span class="math inline">\(n\)</span> into <span class="math inline">\(\pi\)</span> at some location, then there is exactly one such way which will result in <span class="math inline">\(inv(\pi&#39;)-inv(\pi) = k\)</span> and also exactly one way to result in <span class="math inline">\(maj(\pi&#39;)-maj(\pi) = k\)</span> for any <span class="math inline">\(k\in [0,n-1]\)</span>.</p>
</div>
<p>See the figure below for a nice representaton of . </p>
<p>% 5 # {color permutation} We prefer to write the rising-factorial as <span class="math display">\[x(x+1)(x+2)\cdots (x-1+n) = \binom{x-1+n}{x-1}n!\]</span> which is true for all <span class="math inline">\(x\in \mathbb{N}.\)</span> We denote the Stirling number of first kind, i.e. the number of permutations of <span class="math inline">\([n]\)</span> with <span class="math inline">\(k\)</span> cycles by <span class="math inline">\(\genfrac[]{0pt}{}{n}{k}\)</span>. Let <span class="math inline">\(S_n\)</span> be the symmetric group on <span class="math inline">\(n\)</span> elements. We define a  of <span class="math inline">\(\pi\in S_n\)</span> with <span class="math inline">\(x\)</span> colors to be a map <span class="math inline">\(f:[n]\to [x]\)</span> which assigns one of <span class="math inline">\(x\)</span> colors to each element of the permutation. Finally, we say that a coloring is a  if any elements <span class="math inline">\(i,j\)</span> involved in the same cycle of the colored permutation have the same color.</p>
<div class="prop envbox">
<p><strong>Proposition.</strong> <span class="math display">\[\binom{x-1+n}{x-1}n!,\quad\quad \sum_{k=0}^n \genfrac[]{0pt}{}{n}{k}
  x^k\]</span> both count the number of <span class="math inline">\(x\)</span>-color cycle-monochromatic colorings of permutations of <span class="math inline">\([n]\)</span>.</p>
</div>
<figure>
<img src="src/images/ink_img002.png" alt="" /><figcaption>ink</figcaption>
</figure>
<h1 id="exceedences-weak-exceedences">{exceedences, weak exceedences}</h1>
<div class="prop envbox">
<p><strong>Proposition.</strong> The number of permutations with <span class="math inline">\(k\)</span> exceedences is the same as the number of permutations with <span class="math inline">\(k+1\)</span> weak exceedences.</p>
</div>
<h1 id="coloring-with-skips">{coloring with skips}</h1>
Let <span class="math inline">\(\genfrac\{\}{0pt}{}{n}{k}\)</span> denote the number of partitions of <span class="math inline">\([n]\)</span> with <span class="math inline">\(k\)</span> blocks, and let <span class="math inline">\(\genfrac\langle\rangle{0pt}{}{n}{k}\)</span> denote the number of permutations of <span class="math inline">\([n]\)</span> with <span class="math inline">\(k\)</span> descents.
<div class="prop envbox">
<p><strong>Proposition.</strong> <span class="math display">\[\sum_{k\in [n]}\genfrac\{\}{0pt}{}{n}{k}k! x^{n-k} = \sum_{k=0}^{n-1}
\genfrac\langle\rangle{0pt}{}{n}{k} (x+1)^{k},\]</span> because for any <span class="math inline">\(x\in \mathbb{N}\)</span> both quantities count the number of ways to color a permutation of length <span class="math inline">\(n\)</span> with <span class="math inline">\(x\)</span> colors, except that some points are allowed to be left uncolored, in particular descents may not be colored.</p>
</div>
<h1 id="a-map-of-edges-of-k_n">{a map of edges of <span class="math inline">\(K_n\)</span>}</h1>
<p>First we consider <span class="math inline">\(n\)</span> which is even. For each <span class="math inline">\(i\in [n], j\in[\frac{n}{2}-1]\)</span> there is an edge <span class="math inline">\((i,i+j)\)</span> where the addition is done <span class="math inline">\(\mod n\)</span>. Also, there are an additional <span class="math inline">\(\frac{n}{2}\)</span> edges of the form <span class="math inline">\((i, i+\frac{n}{2})\)</span> for <span class="math inline">\(i\in [\frac{n}{2}]\)</span>. For <span class="math inline">\(j&gt;1\)</span>, the edges <span class="math inline">\((i,i+j),(i+1,i+j+1)\)</span> do not share any vertices. For <span class="math inline">\(j=1\)</span> we note that the edges <span class="math inline">\((i,i+1)\)</span> and <span class="math inline">\((i+2,i+3)\)</span> do not share any vertices. Thus the map <span class="math display">\[(i,i+j)\mapsto (i+1,i+j+1) \forall i\in [n],j&gt;1\]</span> <span class="math display">\[(i,i+1)\mapsto (i+2,i+3), \forall i \in [n]\]</span> is a map <span class="math inline">\(f\)</span> of edges such that <span class="math inline">\(e,f(e)\)</span> share no vertices.</p>
<p>For <span class="math inline">\(n\)</span> which is odd, we use a different construction. Let <span class="math inline">\(n=2k+1\)</span> for some <span class="math inline">\(k\in \mathbb{N}\)</span>. For odd <span class="math inline">\(n\)</span> we actually have edges of the form <span class="math inline">\((i,i+j)\)</span> for each <span class="math inline">\(i\in [n], j\in [k]\)</span>. We observe that the following set of edges is “vertex disjoint” (i.e. they share no vertices): <span class="math display">\[(i,i+1), (i+2,i+4), (i+3,i+6), \ldots, (i+k, i+2k).\]</span> Thus, we propose the following map: <span class="math display">\[(i,i+j)\mapsto (i+1,i+j+2)\]</span> where again, everything is <span class="math inline">\(\mod n\)</span>.</p>
<p>Here are some pictures that do a better job describing this:</p>
<p><img src="src/images/ink_img007.png" alt="ink" /> <img src="src/images/ink_img008.png" alt="ink" /></p>
<h1 id="bonus-boolean-lattice">{bonus: boolean lattice}</h1>
<p>more explicitely construct the boolean lattice. 3: needs more than just a picture.</p>
