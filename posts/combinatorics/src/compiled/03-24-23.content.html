<p>A very famous result is that if <span class="math inline">\(\sigma\in S_3\)</span> is any <span class="math inline">\(3\)</span>-letter permutation, then the number of <span class="math inline">\(n\)</span>-letter permutations which avoid <span class="math inline">\(\sigma\)</span> is counted by the catalan numbers <span class="math inline">\(C_n\)</span>, which is pretty cool!</p>
<p>Here’s a proof for <span class="math inline">\(\sigma=231\)</span> (you can check the other <span class="math inline">\(5\)</span> cases yourself, at least one is immediate by symmetry)</p>
<p>So here’s the proof: Let <span class="math inline">\(\pi\in S_n\)</span> be a <span class="math inline">\(231\)</span>-avoiding permutation. Then, the corresponding Dyck path will return to height <span class="math inline">\(0\)</span> for the first time after exactly <span class="math inline">\(2\pi_1\)</span> steps. Now you recursively find the segment before the return, and recursively find the segment after the return.</p>
<p><img src="src/images/ink_img012.png" alt="ink_img012" /> <img src="src/images/ink_img013.png" alt="ink_img013" /></p>
<p>Basically, the key to note is that after you fix <span class="math inline">\(\pi_1\)</span> then you have to deal with everything less than <span class="math inline">\(\pi_1\)</span> before dealing with anything larger than <span class="math inline">\(\pi_1\)</span>, because once you leave the below <span class="math inline">\(\pi_1\)</span> teritory, you can’t return. ever.</p>
<h1 id="another-neat-problem-unrelated">another neat problem; unrelated</h1>
<p>Let <span class="math inline">\(F_n\)</span> denote the <span class="math inline">\(n\)</span>-th fibonacci number. Then: <span class="math display">\[F_{2n}^2 +1 = F_{2n+2}F_{2n-2}.\]</span></p>
<p>some blog-y stuff: you know, this seems like a really easy problem. But as I like to say</p>
<blockquote>
<p>you should try to do lots of problems and not worry too much about them being “too easy”. I didn’t really think it was a very easy problem, it took my a while to think of a solution. I don’t think the amount of time that it takes to solve is particularly relavant though. Really what it means to be a good mathematician is 1. you care about understanding things like this. even if it’s a simple problem, and not an original result or anything; 2. you are willing to persist and stuff. and not get upset about the process, but enjoy it. as I like to say “don’t become so obsessed with where you are going that you forget why you are going there” and forget to take some cool pictures on your way and get dominos. I mean yes, you shouldn’t try to take on too many problems at once either. But trying lots of problems is good.</p>
</blockquote>
<p>anyways that’s just what I like to say. But here’s the solution:</p>
<p><span class="math inline">\(F_n\)</span> counts the number of domino tilings of <span class="math inline">\(2\times n\)</span> rectangle. If we do <span class="math inline">\(F_a\cdot F_b\)</span> this is domino tilings of <span class="math inline">\(2\times (a+b)\)</span> grid, except we ban a domino crossing the <span class="math inline">\(a\)</span> line. So we just have to show a bijection between some sets of domino tilings of a <span class="math inline">\(2\times 4n\)</span> grid, with different banned crossing lines. And we basically do this by just pushing the horizontal domino to the right and bumping out whatever’s in its place and then recursively repeating the bumping stuff.</p>
<figure>
<img src="images/fibs.jpg" alt="" /><figcaption>fibs</figcaption>
</figure>
