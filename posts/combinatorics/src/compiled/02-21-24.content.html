<h1 id="complete-sets">1. complete sets</h1>
<div class="defn envbox">
<p><strong>Definition.</strong> A set <span class="math inline">\(S\)</span> is <span class="math inline">\(r\)</span>-complete if, for any <span class="math inline">\(r\)</span>-coloring of <span class="math inline">\(S\)</span> there is a monochromatic set of numbers in <span class="math inline">\(S\)</span> summing to all sufficiently large values.</p>
</div>
<div class="defn envbox">
<p><strong>Definition.</strong> A set is <span class="math inline">\(\varepsilon\)</span>-complete if, for any subset <span class="math inline">\(S&#39;\)</span> of <span class="math inline">\(S\)</span> with size at least <span class="math inline">\(\varepsilon|S|\)</span> there is a subet of <span class="math inline">\(S&#39;\)</span> summing to all sufficiently large values.</p>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> There are <span class="math inline">\(\varepsilon\)</span>-complete sets of size approx <span class="math inline">\(\varepsilon^{-1}\log^2 n\)</span>.</p>
</div>
First need key lemma. Theorem follows immediately from lemma.
<div class="lem envbox">
<p><strong>Lemma.</strong> Fix <span class="math inline">\(\varepsilon&gt;0, n\in \mathbb{N}\)</span>. There is a set of <span class="math inline">\(\varepsilon^{-1}\log n\)</span> many integers whose set of subsets contains an interval of size <span class="math inline">\(n\log n\)</span> and starts at <span class="math inline">\(n/2\)</span> or something.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> Here we highlight the general technique that seems to be powering a lot of their results.</p>
<ol type="1">
<li>Randomly sample numbers with no prime divisors smaller than <span class="math inline">\((\log n)/2\)</span> (iirc)</li>
<li>For the first little while, whenever you add a number it is quite likely to double the interval of attainable sums.</li>
<li>Then once your interval is rather large and you’ve drawn a bunch of elements you can extend the interval by the size of the drawn elements each time.</li>
</ol>
<p><strong>TODO: figure out details?</strong></p>
</div>
Proof of theorem from lemma:
<div class="pf envbox">
<p><strong>Proof.</strong> Dyadically apply the lemma</p>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> There are no <span class="math inline">\(\epsilon\)</span>-complete sets of size smaller than <span class="math inline">\(\log^2 n\)</span></p>
</div>
<h1 id="avoiding-a-specific-sum">2. avoiding a specific sum</h1>
<div class="thm envbox">
<p><strong>Theorem.</strong> We say a coloring of <span class="math inline">\([n]\)</span> is good if there is no monochromatic set of integers summing to <span class="math inline">\(n\)</span>.</p>
<p>I ignore log factors in following statement.</p>
<p>You need about <span class="math inline">\(n^{1/3}\)</span> colors to be good. There exists a good coloring using <span class="math inline">\(n^{1/3}\)</span> colors.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong></p>
<p>We split our colors up into several types:</p>
<ol type="1">
<li>big elements</li>
<li>multiples of primes not dividing <span class="math inline">\(n\)</span></li>
<li>everything else, grouped into groups with sums smaller than <span class="math inline">\(n\)</span>.</li>
</ol>
<p>It turns out that after handling 1,2 there is not so much stuff left for 3, and what’s left is pretty small. So this ends up being a pretty efficient coloring.</p>
</div>
<h1 id="r-complete-sets">3. <span class="math inline">\(r\)</span>-complete sets</h1>
<div class="prop envbox">
<p><strong>Proposition.</strong> <span class="math inline">\(\left\{ p^{i}q^{j}\right\}\)</span> is not <span class="math inline">\(2\)</span>-complete, but it is <span class="math inline">\(1\)</span>-complete.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> Here is a 2-coloring that demonstrates the set is not 2-complete. Color powers of <span class="math inline">\(p^{i}\)</span> Red. Color everything else Blue. Then all Blue numbers are multiples of <span class="math inline">\(q\)</span>. So both blue and red and severely limited in the numbers they can achieve.</p>
<p><strong>TODO1: prove it is 1-complete</strong></p>
</div>
<div class="rmk envbox">
<p><strong>Remark.</strong> As far as I know it is not known whether <span class="math inline">\(\left\{ p^{i}q^{j}r^{k}\right\}\)</span> is <span class="math inline">\(2\)</span>-complete or not.</p>
<p><strong>TODO2: solve</strong></p>
</div>
<h1 id="subset-sum-free-set">4. subset-sum free set</h1>
<div class="prop envbox">
<p><strong>Proposition.</strong> The set <span class="math inline">\(1,2,4,\ldots, 2^{k-1}\)</span> has the property that all of its subset sums are distinct.</p>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> Let <span class="math inline">\(a_1&lt;a_2&lt;\cdots &lt;a_k\)</span> be positive integers such that all subset sums of <span class="math inline">\(\left\{ a_i\right\}\)</span> are distinct. Then <span class="math inline">\(a_k \ge 2^{k}/\sqrt{k}\)</span>.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong></p>
<p>First we give an easy argument to show <span class="math inline">\(a_k \ge 2^{k}/k\)</span>. If <span class="math inline">\(a_k&lt;2^{k}/k\)</span> then all subset sums would be contained in <span class="math inline">\([2^{k}-1]\)</span>. But there are <span class="math inline">\(2^{k}\)</span> subset sums so they could then not all be distinct.</p>
<p>To prove <span class="math inline">\(2^{k}/\sqrt{k}\)</span> we use second moment method. If you take a random sum it is tightly concentrated.</p>
<p><strong>TODO3: figure this out more</strong></p>
<p>Fox talked about how they did something fancy isoperimetric inequality boolean cube to get a better constant.</p>
<p><strong>TODO4: upper or lower bounds is a kind of fun openq to think about</strong></p>
</div>
<p><strong>UPDATE</strong> The most obvious way to get a subsetsum free set is greedily forwards: repeatedly pick the largest number that is still available. This gives powers of <span class="math inline">\(2\)</span>. Another idea is greedy backwards: start by picking the largest number, and then go backwards, selecting at each step the largest number which is still available.</p>
<p>Turns out the greedy backwards approach gives a neat sequence, and <span class="math inline">\(\approx 0.235\cdot 2^{n-1}\)</span>. This is not SotA. SotA is <span class="math inline">\(.202\cdot 2^{n-1}\)</span> or something.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="co">this is code for erdos distinct sums problem </span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="co">OEIS this</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="co">[13, 12, 11, 9, 6]                              **** 1 1 2 3</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="co">[24, 23, 22, 20, 17, 11]                        **** 1 1 2 3 6</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="co">[44, 43, 42, 40, 37, 31, 20]                    **** 1,1,2,3,6,11</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="co">[84, 83, 82, 80, 77, 71, 60, 40]                **** 1 1 2 3 6 11 20</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="co">[161, 160, 159, 157, 154, 148, 137, 117, 77]    **** 1 1 2 3 6 11 20 40</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="co">[309, 308, 307, 305, 302, 296, 285, 265, 225, 148]</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a><span class="im">from</span> itertools <span class="im">import</span> combinations</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a><span class="kw">def</span> has_distinct_subset_sums(nums, printit<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>    subset_sums <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="bu">len</span>(nums)):</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>        subset_sum <span class="op">=</span> <span class="bu">sum</span>(nums[j] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(nums)) <span class="cf">if</span> (i <span class="op">&gt;&gt;</span> j) <span class="op">&amp;</span> <span class="dv">1</span>)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a>        <span class="cf">if</span> subset_sum <span class="kw">in</span> subset_sums:</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>        subset_sums.add(subset_sum)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>    <span class="cf">if</span> printit:</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a>        <span class="bu">print</span>(subset_sums)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a>        <span class="bu">print</span>(<span class="bu">len</span>(subset_sums))</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a>    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a>n <span class="op">=</span> <span class="dv">24</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a>m <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a><span class="cf">for</span> subset <span class="kw">in</span> combinations(<span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>)), m):</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a>    <span class="cf">if</span> has_distinct_subset_sums(subset):</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a>        <span class="bu">print</span>(subset)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true"></a><span class="kw">def</span> greedy(big):</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true"></a>    X <span class="op">=</span> [big]</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true"></a>    subsetsums <span class="op">=</span> {<span class="dv">0</span>, big}</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(big,<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true"></a>        compatible <span class="op">=</span> <span class="va">True</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true"></a>        <span class="cf">for</span> s <span class="kw">in</span> subsetsums:</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true"></a>            <span class="cf">if</span> s<span class="op">+</span>i <span class="kw">in</span> subsetsums:</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true"></a>                compatible <span class="op">=</span> <span class="va">False</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true"></a>                <span class="cf">break</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true"></a>        <span class="cf">if</span> compatible:</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true"></a>            X.append(i)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true"></a>            Y <span class="op">=</span> [s<span class="op">+</span>i <span class="cf">for</span> s <span class="kw">in</span> subsetsums]</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true"></a>            <span class="cf">for</span> y <span class="kw">in</span> Y:</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true"></a>                subsetsums.add(y)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true"></a>    <span class="cf">return</span> X</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true"></a></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true"></a>record <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">500</span>):</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true"></a>    score <span class="op">=</span> i <span class="op">/</span> <span class="dv">2</span><span class="op">**</span>(<span class="bu">len</span>(greedy(i))<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true"></a>    <span class="cf">if</span> score <span class="op">&lt;</span> record:</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true"></a>        <span class="bu">print</span>(greedy(i))</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true"></a>        record <span class="op">=</span> score</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true"></a>        <span class="bu">print</span>(<span class="bu">round</span>(<span class="dv">100</span><span class="op">*</span>score, <span class="dv">2</span>))</span></code></pre></div>
