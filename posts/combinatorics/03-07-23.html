<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <title>skyspace</title>

    <link href="../../formatting/pandoc.css" rel="stylesheet">
    <link href="../../formatting/envbox.css" rel="stylesheet">
    <link href="../../formatting/bars.css" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.4.1/jquery.easing.min.js" integrity="sha256-H3cjtrm/ztDeuhCN9I4yh4iN2Ybx/y1RM7rMmAesA0k=" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>

  </head>
  <body>
    <div class="wrapper">
      <nav id="sidebar">
        <div id="sidebar-content">
          <div class="sidebar-header">
            <h5>skyspace</h5>
          </div>
          <ul class="list-unstyled components">
            <img style="width:100%; max-width:250px" src="../../images/cat.png" alt="cat"/>
            <li> <a href="../../index.html">Home</a> </li>
            <li> <a href="../../about.html">About</a> </li>
            <li> <a href="../../topics.html">Topics</a> </li>
            <hr>
            <div id="toc">
            <li> <a href="#
" class="js-scroll-trigger">
</a> </li>
            </div>
          </ul>
        </div>
      </nav>

      <div id="content"> 
      <h1 id="uuu-dyck-path">{UUU dyck path}</h1>
<p>Let <span class="math inline">\(C_{n}=\frac{1}{n+1}\binom{2n}{n}\)</span> denote the <span class="math inline">\(n\)</span>-th Catalan number. We have seen that <span class="math inline">\(C_n\)</span> counts the number of Dyck paths with <span class="math inline">\(n\)</span> up steps and <span class="math inline">\(n\)</span> down steps. Let <span class="math inline">\(A_{n}\)</span> denote the number of Dyck paths with <span class="math inline">\(n\)</span> up steps and <span class="math inline">\(n\)</span> down steps where the first <span class="math inline">\(3\)</span> steps are up steps. The goal of this problem is to determine <span class="math inline">\(A_{n}.\)</span></p>
<div class="prop envbox">
<p><strong>Proposition.</strong> <span class="math inline">\(A_{n}=C_n-2C_{n-1}\)</span></p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> The first step of a Dyck path must be up. Then, it can either go up or down. If the first two steps are up steps the third step can also be chosen from up and down.</p>
<p>The total number of Dyck paths is the sum of these three disjoint starting possibilities: UUU, UUD, UD. Note that the number of Dyck paths that start with UUU is precisely <span class="math inline">\(A_n\)</span>, while the number of Dyck paths starting with <span class="math inline">\(UD\)</span> is precisely <span class="math inline">\(C_{n-1}\)</span> because we have arrived back on the <span class="math inline">\(x\)</span>-axis, and the number of Dyck paths starting with UUD is also <span class="math inline">\(C_{n-1}\)</span> because the first mvoe of any Dyck path must be an up step, so we can think of our path from now on as being the remainder of such a path.</p>
<p>Thus, <span class="math display">\[C_n = 2C_{n-1}+A_n.\]</span></p>
<p>Re-arranging gives <span class="math display">\[A_n = C_n - 2C_{n-1} = \frac{1}{n+1}\binom{2n}{n} -
  \frac{2}{n}\binom{2n-2}{n-1} = \binom{2n-2}{n-1}2(n-2) =
  2n(n-2)C_{n-1}.\]</span></p>
<figure>
<img src="src/images/ink_img001.png" alt="" /><figcaption>ink</figcaption>
</figure>
</div>
<h1 id="bijection-of-trees">{bijection of trees}</h1>
<p>We showed in class that the number of plane trees with <span class="math inline">\(n+1\)</span> vertices is <span class="math inline">\(C_n\)</span>, i.e. the number of Dyck paths with <span class="math inline">\(n\)</span> up and <span class="math inline">\(n\)</span> down steps. The bijection is straightforward: take a depth-first traversal of a plane tree with <span class="math inline">\(n+1\)</span> vertices (and thus <span class="math inline">\(n\)</span> edges); each step away from the root is turned into an up step in the Dyck path, and each step towards the root becomes a down step. The process is clearly invertable: we can generate the tree from it’s depth-first traversal sequence. To count Dyck paths, we reasoned as follows in lecture: let <span class="math inline">\(2k \in \left\{ 2,4,6,\ldots, 2n\right\}\)</span> be the first time that the Dyck path comes back down to height <span class="math inline">\(0\)</span>. Then, the Dyck path is clearly composed of an up step, followed by a Dyck path of length <span class="math inline">\(2k-2\)</span> shifted up <span class="math inline">\(1\)</span> unit followed by a down step. After hitting height <span class="math inline">\(0\)</span> we can do another Dyck path now of length <span class="math inline">\(2n-2k.\)</span> This gives the well-known recurrence <span class="math display">\[C_n = \sum_{k=1}^n C_{k-1}C_{n-k} =
\sum_{k=0}^{n-1}C_{k}C_{n-k-1}.\]</span> But it also gives us more than just a recurrence: it gives us a way of thinking about how Dyck paths are recursively composed of smaller shifted Dyck paths.</p>
<p>Now we will show that binary trees with <span class="math inline">\(n\)</span> vertices exhibit the same recursive structure. One consequence of this is that the numbers <span class="math inline">\(B_n\)</span>, which we use to denote the number of binary trees on <span class="math inline">\(n\)</span> vertices, obeys the same recurrence as <span class="math inline">\(C_n\)</span>. But more interestingly, the fact that both objects have the same recursive structure allows us to form an algorithm that converts between the two objects, i.e. a bijection. We can see that a binary tree will have a root, and then some number <span class="math inline">\(k\in 0,1,\ldots, n-1\)</span> of nodes to its left, with the remaining <span class="math inline">\(n-k-1\)</span> of nodes being to the right of the root (i.e. descendants via its right child, if there is a right child). In other words, <span class="math display">\[B_n = \sum_{k=0}^{n-1} B_k B_{n-k-1}.\]</span> Now, checking / defining that <span class="math inline">\(B_0=C_0 = 1, B_1=C_1=1\)</span> suffices to prove that the sequences are equal, but doesn’t quite give us an understanding of why they are equal.</p>
<p>Now we exhibit a bijection between binary trees and dyck paths; combined with our bijection between dyck paths and plane binary trees this constitutes a bijective proof that <span class="math inline">\(B_n = C_n\)</span>.</p>
<p>Consider a binary tree; we associate a Dyck path with it. If the root has no left children, the associated Dyck path starts with up, down and then the remainder of the Dyck path is the Dyck path associated with the right sub-tree. If the root has left children, the associated Dyck path will be up, then the Dyck path for the left sub-tree, and finally down, and then followed by the right sub-tree’s associated Dyck tree (if the right sub-tree is non-empty). The conversion backwards is similarly straightforward. If we consider a segment with length <span class="math inline">\(2k+2\)</span> of a Dyck path that starts and ends at height <span class="math inline">\(0\)</span> but does not touch height <span class="math inline">\(0\)</span> in the middle, then we recursively use this segement to construct the left sub-tree of the root in the associated tree. In particualr, if <span class="math inline">\(k=0\)</span> this corresponds to up down. This is better described via a picture: <img src="src/images/ink_img004.png" alt="ink" /></p>
<h1 id="section">{3}</h1>
<p>The bijection is as follows: draw the non-crossing set partition in a circle as a set of non-crossing polygons by connecting the points in the same parts of the partition. Now, put a “dual vertex” on the midpoint of each edge of the original diagram. Connect two dual vertices iff doing so is possible without crossing the original diagram’s polygons. If the original diagram had <span class="math inline">\(k\)</span> sets in the partition, then this new diagram will have <span class="math inline">\(n-k+1\)</span>. And, if we apply the transformation again then we get back the original set partition, so the transformation is a bijection of non-crossing set partitions with <span class="math inline">\(k\)</span> blocks to those with <span class="math inline">\(n-k+1\)</span> blocks.</p>
<figure>
<img src="src/images/ink_img006.png" alt="" /><figcaption>ink</figcaption>
</figure>
<h1 id="modmaj-modinv">{modmaj, modinv}</h1>
<p>It is well known that major index is equidistributed with number of inversions. Thus, we may consider instead  the number of permutations with a number of inversions which has some <span class="math inline">\(k\)</span> under <span class="math inline">\(\mod n\)</span>. Consider a random permutation. It will have some number of inversions contributed by pairs of elements in <span class="math inline">\([n-1]\)</span>. Then, there will be some inversions which are inversions with element <span class="math inline">\(n\)</span>. If we are considering a random permutation then <span class="math inline">\(n\)</span> is equally likely to be inverted with any number of other elements. If the number of inversions was some number <span class="math inline">\(k\)</span> just counting elements pairs in <span class="math inline">\([n-1]\)</span>, then we see that it will be equally likely to be any value <span class="math inline">\(k+0,k+1,k+2,\ldots, k+n-1\)</span> after considering the last one. But of course, this means that it is uniformly randomly distributed on <span class="math inline">\([n]\)</span> if we consider it <span class="math inline">\(\mod n\)</span>. This is equivalent to the desired result because the probability of having modinv of <span class="math inline">\(k\)</span> is simply the number of permutations with modinv <span class="math inline">\(k\)</span> divided by <span class="math inline">\(n!\)</span>.</p>
In fact, Major index has this same property: that randomly adding <span class="math inline">\(n\)</span> into a permutation of length <span class="math inline">\(n-1\)</span> increases the major index by a uniformly random value in <span class="math inline">\([n]-1\)</span>. Thus, the following Proposition more directly establishes the result desired in the problem.
<div class="prop envbox">
<p><strong>Proposition.</strong>  If we consider each possible way to form <span class="math inline">\(\pi&#39;\)</span> from <span class="math inline">\(\pi\in  S_{n-1}\)</span> by inserting <span class="math inline">\(n\)</span> into <span class="math inline">\(\pi\)</span> at some location, then there is exactly one such way which will result in <span class="math inline">\(inv(\pi&#39;)-inv(\pi) = k\)</span> and also exactly one way to result in <span class="math inline">\(maj(\pi&#39;)-maj(\pi) = k\)</span> for any <span class="math inline">\(k\in [0,n-1]\)</span>.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> For inversions this is obvious: if we place <span class="math inline">\(n\)</span> at position <span class="math inline">\(k\in [n]\)</span> in the one-line notation for the number then it will be inverted with all <span class="math inline">\(n-k\)</span> elements to its right.</p>
This is less obvious for <span class="math inline">\(maj\)</span>, but still true. Again, we fix <span class="math inline">\(\pi\in S_{n-1}\)</span> and consider all ways to add <span class="math inline">\(n\)</span> to <span class="math inline">\(\pi\)</span>, and the corresponding effect on major index. Let <span class="math inline">\(des_\pi(k)\)</span> denote the number of descents after index <span class="math inline">\(k\)</span> in <span class="math inline">\(\pi\)</span>. If we insert <span class="math inline">\(n\)</span> at the end of <span class="math inline">\(\pi\)</span> then the major index does not increase. We break the remaining inserts into two possible cases:
<p>Let <span class="math inline">\(d\)</span> denote the number of descents in <span class="math inline">\(\pi\)</span>. We can see that the annihilating inserts which corresponds to changes of <span class="math inline">\(1+des_\pi(k)\)</span> in major index will range over <span class="math inline">\(1,2,\ldots,  d\)</span>, hitting each value exactly once, because if we go from the right heading left then each annihilation corresponds to another descent which is now to our right. On the other hand, if we consider the non-annihilating inserts starting from the left, i.e. index <span class="math inline">\(1\)</span>, we see that they will range over <span class="math inline">\(d+1, d+2, \ldots, n-1\)</span> hitting each value exactly once. In particular, this is because if we pass an ascent then <span class="math inline">\(k+des_\pi(k)\)</span> increases by <span class="math inline">\(1\)</span> due to <span class="math inline">\(k\)</span> increasing by <span class="math inline">\(1\)</span>, but when we pass a descent <span class="math inline">\(k+des_\pi(k)\)</span> does not change because the increase in <span class="math inline">\(k\)</span> is offset by us having less descents to our right. This concludes the proof.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> As an immediate corollary of , we have that <span class="math inline">\(inv, maj\)</span> have the same generating functions (after checking the base case of course), namely, if we let <span class="math inline">\(inv(n,s)\)</span> denote the number of permutations of <span class="math inline">\([n]\)</span> with <span class="math inline">\(s\)</span> inversions then: <span class="math inline">\(inv(n,s) = \sum_{k=0}^{n-1} inv(n-1, s-k).\)</span></p>
<p>However, we actually also can infer a bijection from  to better understand the relationship between these statistics. In particular we can make a recursive algorithm which forms a bijection <span class="math inline">\(\phi\)</span> such that <span class="math inline">\(maj(\phi(\pi)) = inv(\pi)\)</span>. The bijection is as follows: say you had a permutation <span class="math inline">\(\pi \in S_n\)</span>. Recursively compute <span class="math inline">\(\phi\)</span> on <span class="math inline">\(\pi_0\)</span> which is <span class="math inline">\(\pi\)</span> but with <span class="math inline">\(n\)</span> excluded (i.e. write <span class="math inline">\(\pi\)</span> in one-line notation, and then delete <span class="math inline">\(n\)</span> and interpret the resulting string as a permutation in one-line notation.) Now, in <span class="math inline">\(\pi\)</span>, <span class="math inline">\(n\)</span> is inverted with some number <span class="math inline">\(k\in [0,n-1]\)</span> of other elements. Insert <span class="math inline">\(n\)</span> into <span class="math inline">\(\phi(\pi_0)\)</span> to get <span class="math inline">\(\phi(\pi)\)</span> in such a way that <span class="math inline">\(maj(\phi(\pi)) - maj(\phi(\pi_0)) = k\)</span>.</p>
</div>
<p>See the figure below for a nice representaton of . </p>
<p>% 5 # {color permutation} We prefer to write the rising-factorial as <span class="math display">\[x(x+1)(x+2)\cdots (x-1+n) = \binom{x-1+n}{x-1}n!\]</span> which is true for all <span class="math inline">\(x\in \mathbb{N}.\)</span> We denote the Stirling number of first kind, i.e. the number of permutations of <span class="math inline">\([n]\)</span> with <span class="math inline">\(k\)</span> cycles by <span class="math inline">\(\genfrac[]{0pt}{}{n}{k}\)</span>. Let <span class="math inline">\(S_n\)</span> be the symmetric group on <span class="math inline">\(n\)</span> elements. We define a  of <span class="math inline">\(\pi\in S_n\)</span> with <span class="math inline">\(x\)</span> colors to be a map <span class="math inline">\(f:[n]\to [x]\)</span> which assigns one of <span class="math inline">\(x\)</span> colors to each element of the permutation. Finally, we say that a coloring is a  if any elements <span class="math inline">\(i,j\)</span> involved in the same cycle of the colored permutation have the same color.</p>
<div class="prop envbox">
<p><strong>Proposition.</strong> <span class="math display">\[\binom{x-1+n}{x-1}n!,\quad\quad \sum_{k=0}^n \genfrac[]{0pt}{}{n}{k}
  x^k\]</span> both count the number of <span class="math inline">\(x\)</span>-color cycle-monochromatic colorings of permutations of <span class="math inline">\([n]\)</span>.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> The expression <span class="math inline">\(\genfrac[]{0pt}{}{n}{k}x^k\)</span> counts the number of permutations of <span class="math inline">\([n]\)</span> with <span class="math inline">\(k\)</span> cycles times <span class="math inline">\(x\)</span> choices per cycle for the color of the cycle. Summing over all <span class="math inline">\(k\)</span> this clearly counts the total number of ways to color permutations such that elements in the same cycle get the same color.</p>
<p>Now we count the number of cycle-monochromatic colorings of permutations where we must use <span class="math inline">\(b_1\)</span> of color <span class="math inline">\(1\)</span>, <span class="math inline">\(b_2\)</span> of color <span class="math inline">\(2\)</span>, etc, with <span class="math inline">\(b_i\in [x]\)</span> for each <span class="math inline">\(i\in [x]\)</span> and <span class="math inline">\(\sum b_i = n\)</span>. To construct such a permutation and coloring, we could first decide on which elements will be assigned to each color. This can be accomplished in <span class="math inline">\(n! / \prod_i b_i\)</span> ways; it is equivalent to forming an <span class="math inline">\(n\)</span>-letter word using <span class="math inline">\(b_i\)</span> of letter <span class="math inline">\(i\)</span> and using character <span class="math inline">\(i\)</span> of the word to color the element <span class="math inline">\(i\in  [n]\)</span>. Then, if we have decided which elements to assign to each color class, there are <span class="math inline">\(\prod_i b_i\)</span> ways to make the permutations, where all permutations can only send numbers to other numbers of the same color. In total this means that once we have decided on the partition <span class="math inline">\(b_i\)</span> of how many of each color to use, there are <span class="math inline">\(n!\)</span> ways to perform the coloring and permutation. The number of ways to form this partition is <span class="math inline">\(\binom{x-1+n}{x-1}\)</span> because we can think of inserting <span class="math inline">\(x-1\)</span> dividers into a string of length <span class="math inline">\(n\)</span>, where the dividers will divide the string into color classes. Thus, <span class="math inline">\(\binom{x-1+n}{x-1}n!\)</span> also counts the number of permutations with elements of the same cycle having the same color.</p>
<p>Because the expressions count the same quantity for each <span class="math inline">\(x\in  \mathbb{N}\)</span>, and because they are continuous in <span class="math inline">\(x\)</span>, we have that the two desired expressions are equal.</p>
</div>
<figure>
<img src="src/images/ink_img002.png" alt="" /><figcaption>ink</figcaption>
</figure>
<h1 id="exceedences-weak-exceedences">{exceedences, weak exceedences}</h1>
<div class="prop envbox">
<p><strong>Proposition.</strong> The number of permutations with <span class="math inline">\(k\)</span> exceedences is the same as the number of permutations with <span class="math inline">\(k+1\)</span> weak exceedences.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> Consider a permutation <span class="math inline">\(\pi \in S_n\)</span> written in one-line notation with <span class="math inline">\(k\)</span> exceedences. Note that there is never an exceedence at index <span class="math inline">\(n\)</span>, because <span class="math inline">\(\pi_n&gt;n\)</span> is impossible. Now, form <span class="math inline">\(\pi&#39;\)</span> by moving the final character in <span class="math inline">\(\pi\)</span>’s one-line notation to the start. In other words, <span class="math inline">\(\pi&#39; = \pi_n  \pi_1 \pi_2 \pi_3 \cdots \pi_{n-1}\)</span> in one line notation. Note that there is always a weak exceedence at index <span class="math inline">\(1\)</span> because <span class="math inline">\(\pi&#39;_1 \geq 1\)</span> is trivially satisfied. We claim that there are exactly <span class="math inline">\(k+1\)</span> weak exceedences in <span class="math inline">\(\pi&#39;\)</span>. If we can establish this we are finished because this transformation is a bijection (with the inverse achieved by shifting backwards).</p>
<p>For every index <span class="math inline">\(i&lt;n\)</span> corresponding to an exceedence in <span class="math inline">\(\pi\)</span> we have <span class="math inline">\(\pi_i &gt; i\)</span>. Then, in <span class="math inline">\(\pi&#39;\)</span> we have <span class="math inline">\(\pi_{i+1}&#39; = \pi_{i} &gt; i \implies \pi_{i+1}&#39; \geq i+1\)</span> so there is an exceedence at <span class="math inline">\(i+1\)</span> in <span class="math inline">\(\pi&#39;\)</span>. In fact this is if and only if. If <span class="math inline">\(\pi_i \leq i\)</span> then <span class="math inline">\(\pi_{i+1}&#39; = \pi_{i} \leq i\)</span> so there is not an exceedence at <span class="math inline">\(i+1\)</span> in <span class="math inline">\(\pi&#39;\)</span>.</p>
<figure>
<img src="src/images/ink_img003.png" alt="" /><figcaption>ink</figcaption>
</figure>
</div>
<h1 id="coloring-with-skips">{coloring with skips}</h1>
Let <span class="math inline">\(\genfrac\{\}{0pt}{}{n}{k}\)</span> denote the number of partitions of <span class="math inline">\([n]\)</span> with <span class="math inline">\(k\)</span> blocks, and let <span class="math inline">\(\genfrac\langle\rangle{0pt}{}{n}{k}\)</span> denote the number of permutations of <span class="math inline">\([n]\)</span> with <span class="math inline">\(k\)</span> descents.
<div class="prop envbox">
<p><strong>Proposition.</strong> <span class="math display">\[\sum_{k\in [n]}\genfrac\{\}{0pt}{}{n}{k}k! x^{n-k} = \sum_{k=0}^{n-1}
\genfrac\langle\rangle{0pt}{}{n}{k} (x+1)^{k},\]</span> because for any <span class="math inline">\(x\in \mathbb{N}\)</span> both quantities count the number of ways to color a permutation of length <span class="math inline">\(n\)</span> with <span class="math inline">\(x\)</span> colors, except that some points are allowed to be left uncolored, in particular descents may not be colored.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> First we show LHS accurately counts the combinatorial object we defined in the Proposition statement. The LHS can be interpretted as follows: take an ordered set partition of <span class="math inline">\([n]\)</span>, arrange the elements within each block of the partition in increasing order, and then color all but the final element of each block using any of <span class="math inline">\(x\)</span> colors. The final element of each block is left uncolored. This corresponds exactly to a permutation where descents and some other points have been left uncolored, but each other point is colored with one of <span class="math inline">\(x\)</span> colors. In particular, the set partition is recoverable from the colored permutation by writing the permutation in one-line notation, and breaking it into pieces on the non-colored elements.</p>
<p>Now we show that the RHS counts the same quantity. Actually, for the RHS we should first make use of the fact that Euler numbers are symmetric, i.e. <span class="math inline">\(\genfrac\langle\rangle{0pt}{}{n}{k} =  \genfrac\langle\rangle{0pt}{}{n}{n-k-1}\)</span> which is because given a permutation <span class="math inline">\(\pi\)</span> with <span class="math inline">\(k\)</span> descents, the permutation <span class="math inline">\(\pi^{-1}\)</span> has <span class="math inline">\(n-k-1\)</span> descents. Thus we may re-write the RHS as <span class="math display">\[\sum_{k=0}^{n-1}\genfrac\langle\rangle{0pt}{}{n}{k}(x+1)^{n-k-1}.\]</span> Now we can interpret the RHS combinatorially as saying take a permutation with some number <span class="math inline">\(k\)</span> of descents, and then color each non-descent element with one of <span class="math inline">\(x\)</span> colors, or decline to color it (this is the <span class="math inline">\(+1\)</span>). Again, we see that this corresponds exactly to generating a permutation colored according to our specification. Thus the expressions are equal.</p>
<figure>
<img src="src/images/ink_img009.png" alt="" /><figcaption>ink</figcaption>
</figure>
</div>
<h1 id="a-map-of-edges-of-k_n">{a map of edges of <span class="math inline">\(K_n\)</span>}</h1>
<p>First we consider <span class="math inline">\(n\)</span> which is even. For each <span class="math inline">\(i\in [n], j\in[\frac{n}{2}-1]\)</span> there is an edge <span class="math inline">\((i,i+j)\)</span> where the addition is done <span class="math inline">\(\mod n\)</span>. Also, there are an additional <span class="math inline">\(\frac{n}{2}\)</span> edges of the form <span class="math inline">\((i, i+\frac{n}{2})\)</span> for <span class="math inline">\(i\in [\frac{n}{2}]\)</span>. For <span class="math inline">\(j&gt;1\)</span>, the edges <span class="math inline">\((i,i+j),(i+1,i+j+1)\)</span> do not share any vertices. For <span class="math inline">\(j=1\)</span> we note that the edges <span class="math inline">\((i,i+1)\)</span> and <span class="math inline">\((i+2,i+3)\)</span> do not share any vertices. Thus the map <span class="math display">\[(i,i+j)\mapsto (i+1,i+j+1) \forall i\in [n],j&gt;1\]</span> <span class="math display">\[(i,i+1)\mapsto (i+2,i+3), \forall i \in [n]\]</span> is a map <span class="math inline">\(f\)</span> of edges such that <span class="math inline">\(e,f(e)\)</span> share no vertices.</p>
<p>For <span class="math inline">\(n\)</span> which is odd, we use a different construction. Let <span class="math inline">\(n=2k+1\)</span> for some <span class="math inline">\(k\in \mathbb{N}\)</span>. For odd <span class="math inline">\(n\)</span> we actually have edges of the form <span class="math inline">\((i,i+j)\)</span> for each <span class="math inline">\(i\in [n], j\in [k]\)</span>. We observe that the following set of edges is “vertex disjoint” (i.e. they share no vertices): <span class="math display">\[(i,i+1), (i+2,i+4), (i+3,i+6), \ldots, (i+k, i+2k).\]</span> Thus, we propose the following map: <span class="math display">\[(i,i+j)\mapsto (i+1,i+j+2)\]</span> where again, everything is <span class="math inline">\(\mod n\)</span>.</p>
<p>Here are some pictures that do a better job describing this:</p>
<p><img src="src/images/ink_img007.png" alt="ink" /> <img src="src/images/ink_img008.png" alt="ink" /></p>
<h1 id="bonus-boolean-lattice">{bonus: boolean lattice}</h1>
<p>more explicitely construct the boolean lattice. 3: needs more than just a picture.</p>

      </div>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full"></script>
    <script src="../../formatting/scrolling-nav.js"></script>

    <script charset="utf-8">
        var pres = document.querySelectorAll("pre>code");
        for (var i = 0; i < pres.length; i++) {
            hljs.highlightBlock(pres[i]);
        }
    </script>

    <div id="disqus_thread"></div>
    <script>
      /**
      *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
      *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
      /*
      var disqus_config = function () {
      this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
      };
      */
      (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://awestovergithubioskyspace.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    <script id="dsq-count-scr" src="//awestovergithubioskyspace.disqus.com/count.js" async></script>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-P9YVJX8W9R"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-P9YVJX8W9R');
</script>

  </body>
</html>
