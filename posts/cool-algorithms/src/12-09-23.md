{title}
cycles
{contents}
Cycles-versus-triangles
Girth
virginia lecture 11 stuff
{description}
Some notes about algorithms for finding cycles in graphs.
{body}

The topic today is taken from [Virginia Williams' MM + Graph Algs lecture notes](https://people.csail.mit.edu/virgi/6.890/). Throughout the post $\omega<2.4$ is the matrix multiplication exponent.
MM will stand for matrix multiplication.

# Cycles versus triangles

beg thm 
Let $k\in \N_{\ge 3}$ be a constant. 
directed/undirected-$k$-cycle detection can be accomplished in $n^{\omega}$ time on
$n$-vertex graphs.
end thm
beg pf
It suffices to prove the theorem for directed graphs. We won't
need to explicitely mention this throughout the proof, but just
note that the adjacency matrices needn't be symmetric. 

For $k=3$ you can just cube the adjacency matrix and check
whether its trace is $0$. This doesn't work for $k>3$ because
powers of the adjacency matrix count walks, i.e., are allowed to
repeat vertices. 

Instead we do color coding!
Color with $k$ colors. 
Make matrices $A_1,A_2,\ldots, A_{k-1}$
where $A_i$ represents the transition from color $i$ vertices to
color $i+1$ vertices. That is, fix some ordering of the vertices
within each color class, and then make the rows of $A_i$ be the
vertices of color $i$ and the columns of $A_i$ be the vertices of
color $i+1$, and place edges if the vertices are adjacent.

Let $B = A_1\cdot A_2\cdots A_{k-1}$; $B$ can be computed in
$n^{\omega}$ time.
$B[u,v]$ counts the number of $k$-vertex paths from $u$ to $v$
whose vertices are colors $1,2,\ldots, k$.

Now, for each $u,v$ check whether $A[v,u]=1 \land B[u,v]>0$. If
the check ever passes then we have found a $k$-cycle.

If the cycle was correctly colored we must find a $k$-cycle in
this manner. 

The coloring succeeds with probability $\frac{1}{k^{k}}\ge
\Omega(1)$.
Taking $\Omega(\log n)$ tries for the coloring lets us succeed at
least once with high probability.

![src/images/graph1.png](src/images/graph1.png)

end pf

> Is this tight? Turns out it is for odd cycles but not for even.

beg thm
"Even cycles Even Faster" 

1. For all $k$, there is an $n^{2}$ algorithm to detect existence of a $2k$ cycle (and find it, if it exists).
2. There is an $n^{2}$ time algorithm to find the shortest even cycle.
end thm

First I present two simple proofs of the theorem for $k=2$.
Then I'll present a proof for general $k$.

beg pf
1. Common neighbor(x,y): 
  make an $n \times n$ matrix $A$. $A[i,j]$ will store whether we
  have found a common neighbor for $i,j$ so far. 
  If any cell in the matrix ever gets hit twice then we found a
  $4$-cycle.

  What we do is, for each vertex $v$, for each pair of vertices
  in $N(v)$ mark them as having a common neighbor. 
end pf
beg pf
2. wlog its bipartite:
  In particular, take $G=(V,E)$, and form $G'$ by duplicating the
  vertex set to $V\sqcup V'$ and put an edge between  $uv'$ if $uv$ is an edge in $G$.
  Then, if you had a $4$-cycle in $G$ it is converted into a
  $4$-cycle in $G'$. But of course $G'$ is bipartite and only
  a constant-factor larger.
   Then, run BFS-cycle out of each vertex (for depth $2$).
This must terminate fast. 
More precisely, for all vertices in the neighbor-set of one of
your vertices color their left-neighbors. If a left-neighbor gets
colored twice it means you have a $C_4$.
end pf
beg pf 
goal: check whether our graph contains a $2k$-cycle
Note: wlog $m\le 200 n^{1+\frac{1}{k}}$ or else we are guaranteed to have a
$2k$-cycle (even, super-saturation of $2k$-cycles. anyways, we
can find them.)

**Case 1:** There exists a high degree vertex, say with degree larger
than $H$ somewhere on the cycle.
There aren't so many vertices like this. It costs $\frac{m}{H} n$
to just BFS-cycle out of all the high degree vertices.

**Case 2**: Negation of case 1. i.e., all vertices on the cycle have degree smaller than $H$.
Then we can do BFS-cycle a bit more efficiently, in time $n H^{k}$.

Balancing (1) and (2) gives:

$$ \frac{m}{H}n = nH^{k} \implies H = m^{1/(k+1)}.$$

This yields running time 
$$n m^{k/(k+1)} \le n n^{(1+1/k)(k/(k+1))} = n^{2}.$$

end pf


Now I establish that odd cycle detection does require $n^{\omega}$ time.
First we prove another interesting result:

beg thm
Let $k$ be an odd constant. Then directed-$k$-cycle is equivalently hard to undirected-$k$-cycle.
end thm
beg pf
We can convert an instance of undirected-$k$-cycle to
directed-$k$-cycle by thinking of each edge $\set{u,v}$ as being
two directed edges $u\to v$ and  $v\to u$.

The other direction is more subtle.
We are given an instance of directed-$k$-cycle.
By color coding we assume that the graph has parts
$V_1,V_2,\ldots, V_k$ and we only consider edges from $V_i\to
V_{i+1}$.
Let this new graph be $G'$.

Let $G''$ be the graph obtained by dropping the directionality on
the edges in $G'$. 

**Claim**: $G''$ has an undirected-$k$-cycle iff colorful $G'$ has
a directed $k$-cycle. 

Proof of claim:
If $G'$ has a cycle then dropping the directionality won't kill
the cycle. 
If the cycle in $G''$ uses a vertex from each of the $k$ parts
$V_i$ then it is clearly a cycle in $G'$. 
Assume for contradiction that there is a cycle in $G''$ that
doesn't use some part $V_i$. But $G''\setminus V_i$ is bipartite,
so it cannot contain an odd cycle. 


![Depictionn of the layered grahp](src/images/graph2.png)

![Why this breaks if k is even](src/images/graph3.png)

end pf

beg thm
Let $k$ be a constant.
Directed-$k$-cycle is equivalently hard to triangle detection.
end thm
beg pf
We already showed how to solve directed-$k$-cycle with MM. 

Let $G = (V, E)$ be a graph we want to do triangle detection in. 
Make $k$ copies of the vertex set: $V_1,V_2,\ldots, V_k$.
We denote the copies of a vertex $v$ by $v_1,v_2,\ldots, v_k$.

- Connect $u_1\to v_2 \in V_1 \times V_2$ iff $(u,v)\in E(G)$. 
- Connnect $u_k\to v_1 \in V_{k}\times V_1$ iff $(u,v) \in E(G)$
- For each $i\in [2, k-1]$ and each vertex $v\in V$ connect $v_i\to v_{i+1}\in V_i \times V_{i+1}$.

  A $k$-cycle in this new graph corresponds to a triangle in the
  original graph.

end pf

# Girth

**GIRTH**: length of shortest cycle

### $2$-approx in $n^{1.5}$ time

beg rmk
  In "New Subquadratic Approximation Algorithms for the Girth"
  Knudsen talks about Virginia and Roditty's paper. He observes that her
  algorithm outputs a cycle of size $2\ceil{g/2} + 2\ceil{g/4}$
  when the girth is $g$. 
  So technically for $g=3$ this is a $2$-approx. But for larger
  values of $g$ it is essentially a $1.5$-approx. 
  And her algo is indeed $n^{5/3}$.

  Note:
  Knudsen gives a sub-quadratic algorithm that, if the girth is
  $g$, returns a cycle with size at most 
  $$2\ceil{g/2}+2\ceil{\frac{g}{2(k-1)}}\le (1+\eps)g + 3,$$
  for suitably large $k$, although the run time is of course $n^{2-1/k}$.

  So I feel like the barrier to an $o(n^{2})$ $(2-\eps)$-approx
  is really "given a graph with girth $3$, can you find any of 
  a triangle, a square, or a pentagon in subquadratic time?"


end rmk

beg thm
There is an algorithm that, given an $n$-vertex graph $G$ with
girth $g\ge 3$ outputs a cycle of length at most
$$2\ceil{g/2}+2\ceil{g/4}\le 2g,$$
in running time $n^{5/3}$. 
end thm

beg rmk
If you want to turn the decision problem stated above into
actually an algorithm for finding the shortest cycle, then you
can do the standard binary search trick.
end rmk

---

beg pf
**CAUTION** I have not been especially careful with the floors
and ceilings in this proof. They are really important if you care about small $g$! Beware.

Let $C$ be a length $g$  cycle in $G$.
Call a ball **huge** if it has size larger than $n^{1/3}$.

**Case 1:** 
Some vertex $v\in C$ has a huge $t$-radius ball, for some $t\le \ceil{g/4}$.
Then, if we randomly sample a subset $S$ of size  $n^{2/3}\log n$ we
intersect with $B$ with high probability. 
Imagine we ran BFS-cycle out of $y\in B$. Then we would find a
cycle of length at most $g+2t \le 2g$. 
So what we do is run BFS-cycle out of all the points in $S$.
The cost of this is $n^{2/3} \cdot n\le n^{5/3}$.

**Case 2:** No vertices on the cycle have huge $\ceil{g/4}$-radius balls. 
Sort the vertices in the graph as $v_1,v_2,\ldots, v_n$ based on how fast their ball gets
huge, i.e., the smallest $k$ such that their radius-$k$ ball is
huge. In particular, make it so that $v_1$'s ball becomes huge
the slowest  and $v_n$'s ball becomes huge the fastest.
Let $H_k$ denote the induced subgraph on $v_1,v_2,\ldots, v_k$.

We do a BFS-Cycle from vertex $k$ in $H_k$ for each $k$, except we stop once we
have visited $n^{2/3}$ vertices. 
Let $k_0$ be the first index when all vertices of $C$ are
contained in $H_{k_0}$. We claim that doing this limited BFS in
$H_{k_0}$ will find a cycle of length at most $2g$.

Note that all vertices $v\in H_{k_0}$  satisfy $|B(v, \ceil{g/4})| \le n^{1/3}$ and thus $|B(v, 2\ceil{g/4})|\le n^{2/3}$.
Thus the BFS-cycle out of $k_0$ will successfully find a cycle of
length like at most $4\ceil{g/4}+1$ ish.

The run time of doing this is going to be $n\cdot n^{2/3}\le n^{5/3}$.

end pf

---

beg thm (Due to Knudsen et al, also from the paper "New
Subquadratic Approximation Algorithms for the Girth".)

There is a (multiplicative) $\bigO(1)$-approx for girth with
running time  $n^{2+1/k}$ for any constant $k$.
end thm
beg pf 
We present it for $k=5$ for simplicity. 

We are going to give a $31$-approximation or something.

Do each of the following things:
- Sample a set of $n$ vertices, BFS-Cycle for $n^{1/5}$ steps out
    of each of them.
- Sample a set of $n^{4/5}\log n$ vertices, BFS-cycle for $n^{2/5}$ steps out of each of these vertices.
- Sample a set of $n^{3/5}\log n$ vertices, BFS-cycle for $n^{3/5}$ steps out of each of these vertices.
- Sample a set of $n^{2/5}\log n$ vertices, BFS-cycle for $n^{4/5}$ steps out of each of these vertices.
- Sample a set of $n^{1/5}\log n$ vertices, BFS-cycle for $n^{5/5}$ steps out of each of these vertices.

    Let $C$ be a minimum length cycle.

Let $r_0$ be the minimum $r>0$ such that  $|B(C, \ceil{g/2}(2^{r}-1))|  \le n^{r/5}$.
Then we have that $|B(C, \ceil{g/2}(2^{r_0-1}-1))|  > n^{(r_0-1)/5}$.

We claim that we will find a pretty short cycle when we run the
$r_0$-th itteration of our for-loop. 

By a calculation we find that we will, with high probability, get some vertex $u \in B(C, \ceil{g/2}(2^{r_0-1}-1))$ in the set of size $n^{\frac{6-r_0}{5})} \log n$ that we sample. 
Then if we BFS-cycle out of this dude we get the desired short
cycle. 

end pf

---

### A worse algorithm:

beg prop
2-approx  in $n^2$ time.
end prop
beg pf
Let $G=(V, E)$. 
form a new graph with vertex sets $V, V'$. make an edge $xy' \in G'$
for $x\in V, y'\in V' \iff xy\in E(G)$. So $G'$ is bipartite. 
claim: If G' has a cycle of length $k$ then G has a cycle of length at least $k/2$. 
proof: I brute-forced k=6. It seems like it should be true in general. 

recall: "even cycles even faster": we can find even cycles (even
is redundant because G' is bipartite but whatever) in G' in $n^2$ time.

end pf

beg rmk
this is strictly worse in every way (except maybe
simplicity) than the $1.5$-approx in $n^{2}$ time proved above. 
end rmk

### $o(n^2)$ additive $+25$ approximation assuming $g<100$

beg thm
There is an algorithm that, on graphs of girth $g\le 100$ outputs a
cycle of length at most $g+25$ in time $O(n^{1.999})$
end thm
beg pf

If 
$$m \ge \Omega( n^{1+ \frac{1}{\floor{(g+25)/2}} }) $$
then we have super-saturation of $2\floor{(g+25)/2}$-cycles.
So wlog may assume this is not the case. 
Now, high-deg low-deg cases.

- High deg cost: $n\cdot m/H$. 
- Low deg cost: $n\cdot H^{\ceil{g/2}}$.

Balancing:
$$H = m^{\frac{1}{\ceil{g/2}+1}}.$$

So the cost is 
$$n m^{ \frac{\ceil{g/2}}{\ceil{g/2}+1} } \le n n^{\frac{\ceil{g/2}}{\ceil{g/2}+1}  \cdot (1+\frac{1}{\floor{(g+25)/2}})}.$$

not clear how good this is.

end pf


### additive $1$-approximation for girth in $n^2$ time

beg thm
Given a graph $G$ of girth $g$ we will find a cycle of length at
most $g+1$ in time $O(n^{2})$.
Futhermore, if $g$ is even the cycle we find will actually be of
length $g$.
end thm
beg pf
Algorithm: BFS-Cycle out of every vertex.
Run time: $O(n^{2})$.
end pf

### Exact Algorithm for Girth in $n^{\omega}$ time

beg thm
Exact Algorithm for Girth in $n^{\omega}$ time.
end thm
beg pf
First run the additive $1$-approximation. 

If it outputs a cycle of odd length we know it is equal to the
girth. 
Else, call the length of the ouput cycle $2\ell$. The girth is
either  $2\ell$ or $2\ell-1$.

So, now we would just like to determine whether $G$ has a cycle
of length $2\ell-1$. At the beginning of this blog post we showed
how to solve this with $2\ell-2$ matrix multiplications.
But that's not going to cut it here, we don't really have a bound
on $\ell$.

Here's how we construct a triangle-detection instance:
Make a new graph $G'$.
Place $G$ in $G'$. Then create copies of the vertices. Connect
$v\in V(G)$ and copy the copy $w'$ of $w\in V(G)$ if $dist(v,
w)=\ell-1$. We know this distance because of our BFS-ing.

$G'$ has a triangle iff $G$ has an $(2\ell-1)$-cycle.
![ink_img002](images/ink_img002.png)

end pf

-------- 
--------

## virginia lecture 11 stuff

beg thm
$\widetilde{O}(n^{3}/m)$ time $+3$ additive girth approx.
end thm
beg pf

- case 1: graph has $O(n\log n)$ edges: just give up and do a
    quadratic time algorithm. 
- case 2: graph has enough edges that we can find a good enough
    cycle via super-saturation: then just do that 
- case 3: graph is reasonably sparse, but not crazy sparse. 
  * case 3.1: assume that all vertices on the cycle have degree at most $n^{1/k}$.
    - BFS-cycle for $k-1$ levels, only visiting low degree vertices. 
  * case 3.2: there is a high degree vertex on the cycle. sample
      $n/H$ vertices. *this won't necessarily hit a high degree
      vertex, but should at least hit a neighbor of a high degree
      vertex*. So we could do a $+3$ approx this way. Very few
      vertices we need to BFS out of here.

end pf


beg thm 

- "Finding and Counting Given Length Cycles" Alon Yuster Zwick:
- $m^{4/3}$ algorithm for $C_4$'s
- $m^{13/8}$ algorithm for $C_6$'s
- Count number of $C_k$'s for $k\le 7$ in $n^{\omega}$ time.
    Unlikely to be possible for $C_8$'s because $K_4$'s are
    harder than $K_3$'s.

end thm

## some questions

- subquadratic additive girth approx?

## list of things to look up 

relevant graph parameters that we could do case-work on:
- degeneracy
- capped walls?
- arboricity

