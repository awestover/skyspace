<p><strong>Work in progress</strong></p>
<p>In this blog post I summarize “Stronger 3-SUM Lower Bounds for Approximate Distance Oracles via Additive Combinatorics” by Abboud Bringmann and Fischer and also discuss the very similar “Removing Additive Structure in 3sum based reductions” by Jin and Xu. I will present the results “backwards”, because I think this makes the motivation clear. In particular, I will present the results in the following order:</p>
<ol type="1">
<li>Reduction from “sparse triangle listing” to <span class="math inline">\(C_4\)</span>-enumeration.</li>
<li>Reduction from 3SUM instance with <span class="math inline">\(n^{2+\delta}\)</span> additive energy to sparse triangle listing.</li>
<li>Reduction from 3SUM instance with <span class="math inline">\(O(n^{3-\varepsilon})\)</span> additive energy to 3SUM instance with <span class="math inline">\(n^{2+\delta}\)</span> additive energy.</li>
<li>Reduction from 3SUM instance with <span class="math inline">\(\Theta(n^{3})\)</span> additive energy to 3SUM with <span class="math inline">\(n^{3-\varepsilon}\)</span> additive energy.</li>
</ol>
<p>Before giving the proofs, it will be helpful to state all the results.</p>
<div class="rmk envbox">
<p><strong>Remark.</strong> The 3SUM problem is, given a list of numbers, are there any <span class="math inline">\(3\)</span> summing to <span class="math inline">\(0\)</span>? The 3SUM conjecture states that there is no <span class="math inline">\(n^{2-\varepsilon}\)</span> algorithm for 3SUM.</p>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> 3SUM is “just as hard” when restricted to sets with additive energy <span class="math inline">\(n^{2.9999}\)</span>.</p>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> 3SUM is “just as hard” when restricted to sets with <span class="math inline">\(n^{2.0001}\)</span> additive energy.</p>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> Fix <span class="math inline">\(\varepsilon&gt;0, k_{\max}\ge 3\)</span>. The <strong>sparse triangle listing</strong> problem is, given an <span class="math inline">\(n\)</span>-vertex graph <span class="math inline">\(G\)</span> where all vertices have degrees in <span class="math inline">\(\Theta(\sqrt{n})\)</span> and where <span class="math inline">\(G\)</span> has at most <span class="math inline">\(O(n^{k/2})\)</span> <span class="math inline">\(k\)</span>-cycles for each <span class="math inline">\(k\in [3,k_{\max}]\)</span> list all the triangles. Under the 3SUM conjecture there is no <span class="math inline">\(O(n^{2-\varepsilon})\)</span>-time algorithm for sparse triangle listing.</p>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> Assuming the 3SUM conjecture, there is no <span class="math inline">\(C_4\)</span> enumeration algorithm in time <span class="math inline">\(\widetilde{O}(n^{2-\varepsilon}+t)\)</span> or <span class="math inline">\(\widetilde{O}(m^{4/3-\varepsilon}+t)\)</span> where <span class="math inline">\(t\)</span> is the number of <span class="math inline">\(C_4\)</span>’s.</p>
</div>
<h1 id="cycle-enumeration">4-cycle enumeration</h1>
<p>In this section we reduce sparse triangle listing to <span class="math inline">\(C_4\)</span>-enumeration.</p>
<div class="pf envbox">
<p><strong>Proof.</strong> Assume that we have a <span class="math inline">\(C_4\)</span> enumeration algorithm with running time <span class="math inline">\(\widetilde{O}(n^{2-\varepsilon}+t)\)</span> (where <span class="math inline">\(t\)</span> is the number of <span class="math inline">\(C_4\)</span>’s).</p>
<p>Randomly partition the vertex set into <span class="math inline">\(s=n^{\varepsilon/4}\)</span> parts: <span class="math inline">\(V=V_1\sqcup V_2 \sqcup \cdots \sqcup V_s\)</span>. For each tripple <span class="math inline">\(i,j,k \in [s]^{3}\)</span>, we make a graph <span class="math inline">\(G_{ijk}\)</span>. In <span class="math inline">\(G_{ijk}\)</span> we make 4 copies <span class="math inline">\(v_1,v_2,v_3,v_4\)</span> of each vertex <span class="math inline">\(v\in V_i\sqcup V_j \sqcup V_k\)</span>. We add the following edges:</p>
<ul>
<li><span class="math inline">\(\{v_1, w_2\}\)</span> if <span class="math inline">\(\{v,w\}\in E(G)\)</span></li>
<li><span class="math inline">\(\{v_2, w_3\}\)</span> if <span class="math inline">\(\{v,w\}\in E(G)\)</span></li>
<li><span class="math inline">\(\{v_3, w_4\}\)</span> if <span class="math inline">\(\{v,w\}\in E(G)\)</span></li>
<li><span class="math inline">\(\{v_1,v_4\}\)</span></li>
</ul>
<p><strong>Claim 1:</strong> Each triangle in <span class="math inline">\(G[V_i\sqcup V_j \sqcup V_k]\)</span> becomes a <span class="math inline">\(C_4\)</span> in <span class="math inline">\(G_{ijk}\)</span>.</p>
<p><strong>Claim 2:</strong> Each <span class="math inline">\(C_4\)</span> in <span class="math inline">\(G_{ijk}\)</span> either corresponds to a <span class="math inline">\(C_4\)</span> in <span class="math inline">\(G[V_i\sqcup V_j \sqcup V_k]\)</span> or a <span class="math inline">\(C_3\)</span> in <span class="math inline">\(G[V_i\sqcup V_j \sqcup V_k]\)</span>. And each <span class="math inline">\(C_4,C_3\)</span> in <span class="math inline">\(G\)</span> generates <span class="math inline">\(O(1)\)</span> <span class="math inline">\(C_4\)</span>’s in <span class="math inline">\(G_{ijk}\)</span>’s.</p>
<p>Proof by picture of Claims 1 and 2: <img src="src/images/ink_img009.png" alt="ink_img009" /></p>
<p><strong>Claim 3:</strong> Thus, the number of <span class="math inline">\(C_4\)</span>’s across all <span class="math inline">\(G_{ijk}\)</span> is at most <span class="math inline">\(O(n^{2}/s + n^{3/2})\)</span>.</p>
<p>proof: Each <span class="math inline">\(C_4\)</span> from <span class="math inline">\(G\)</span> survives the slicing with probability <span class="math inline">\(1/s^{4}\)</span>. Thus, the expected number of survivors is <span class="math inline">\(ts^{3}/s^{4}\)</span> (where <span class="math inline">\(t\)</span> is number of <span class="math inline">\(C_4\)</span>’s). By assumption there are at most <span class="math inline">\(O(n^{2})\)</span> <span class="math inline">\(C_4\)</span>’s in <span class="math inline">\(G\)</span> so this is bounded by <span class="math inline">\(O(n^{2}/s)\)</span>.</p>
<p>The number of triangles in <span class="math inline">\(G\)</span> is <span class="math inline">\(O(n^{3/2})\)</span>.</p>
<p>Adding these up gives the desired bound.</p>
<!-- can we do something similar for C6's ? but stronger in terms
of the sparseness? like the sqrt{n} regular is the wrong regime?-->
<p><strong>claim 4</strong>: Algo run time is <span class="math inline">\(O(n^{2-\varepsilon/4})\)</span>. The run time is bounded by <span class="math display">\[\sum_{ijk\in [s]^{3}} n^{2-\varepsilon}+t_{ijk} \le
n^{2-\varepsilon+(3/4)\varepsilon} + n^{2-\varepsilon/4} \le \widetilde{O}(n^{2-\varepsilon/4}).\]</span></p>
<p>This same computation would show that you’re toasted if you were assuming the existence of an <span class="math inline">\(m^{4/3-\varepsilon}\)</span> time algorithm instead.</p>
<p>I think the tilde everywhere is because we have given an algo with a certai expected running time, and in order to boost this to working in the desired time whp we can repeate it <span class="math inline">\(\log n\)</span> times, terminating if its taking longer than twice the expectation.</p>
</div>
<div class="rmk envbox">
<p><strong>Remark.</strong> Everything would go through identically in the above proof if you replaced “sparse triangle listing” problem with “sparse pentagon listing” problem. Of course, the difference is that I don’t know a proof based on 5sum that “sparse pentagon listing” is hard. Also I’m not sure what to define “sparse pentagon listing” as.</p>
</div>
<h1 id="sparse-triangle-listing">sparse triangle listing</h1>
<div class="pf envbox">
<p><strong>Proof.</strong> Let <span class="math inline">\(G = \mathbb{F}_p^{O(\log n)}\)</span> be the group that all our sets live in. Our 3sum instance is an <span class="math inline">\(n\)</span>-element set <span class="math inline">\(A\subset G\)</span>, which we may assume by the theorem about decreasing energy has additive energy at most <span class="math inline">\(O(n^{2.0001})\)</span>.</p>
<p>Let <span class="math inline">\(G&#39;\)</span> be a subgroup of <span class="math inline">\(G\)</span> with size <span class="math inline">\(\sqrt{n}\)</span>.</p>
<p>Let <span class="math inline">\(h_1,h_2,h_3: G\to G&#39;\)</span> be random projections. <!-- (You would have projections $h_1,\ldots, h_5$ if you were trying --> <!-- all edges sparse pentagon) --></p>
<p>Construct a tripartite graph as follows:</p>
<p>Vertex set <span class="math inline">\(X\sqcup Y \sqcup Z\)</span> with <span class="math display">\[X = G&#39; \times G&#39; \times \{0\},\]</span> <span class="math display">\[Y = G&#39; \times \{0\} \times G&#39;,\]</span> <span class="math display">\[Z = \{0\} \times G&#39;  \times G&#39; .\]</span></p>
<p>Edge set: For each <span class="math inline">\(a\in A\)</span>, place an edge <span class="math inline">\(\{x,y\}\in X\times Y\)</span> if <span class="math inline">\(y=x+h(a)\)</span>. etc.</p>
<p><strong>pseudo-solution</strong>: <span class="math inline">\(h(a)+h(b)+h(c)=0\)</span>. <strong>real solution:</strong> <span class="math inline">\(a+b+c=0\)</span>.</p>
<p><strong>claim 1</strong> psuedo-solutions basically correspond to triangles, so triangle listing would suffice to sift through all the pseudo-solutions and find a real solution. More precisely, each pseudo-solution turns into <span class="math inline">\(O(1)\)</span> triangles and the labels on each triangle correspond to a pseudo-solution.</p>
<p>Here’s why: if you have a triangle, i.e., a closed walk, then its gotta satisfy <span class="math inline">\(h(a)+h(b)+h(c)=0\)</span> or it isn’t a <strong>closed</strong> walk.</p>
<p>The reverse side is a bit more subtle but not too bad. I claim that for any <span class="math inline">\(a,b,c\)</span> with <span class="math inline">\(h(a)+h(b)+h(c)=0\)</span> it generates at most <span class="math inline">\(6\)</span> triangles. Basically you gotta satisfy some system of equations. And the only way to do it is</p>
<p><span class="math display">\[x_1=-h_1(a), x_2=-h_2(a)-h_2(b), x_3=-h_3(a)-h_3(b)-h_3(c)=0,\]</span> and then to define <span class="math inline">\(y\)</span>’s and <span class="math inline">\(z\)</span>’s based on the <span class="math inline">\(x\)</span>’s in the obvious manner. <!-- *(for sparse pentagon listing you would have like $x_1=-h_1(a), --> <!-- x_2=-h_2(a)-h_2(b),$ and so on)* --></p>
<p><strong>claim 2</strong>: Probably not too many triangles. More precisely, there are two cases:</p>
<ul>
<li>case 1: there are more than <span class="math inline">\(n^{3/2}\)</span> real solutions to the 3sum instance. In this case we can guess like <span class="math inline">\(\sqrt{n}\log n\)</span> <span class="math inline">\((a,b, -a-b)\)</span> triples and with high probability we will hit a solution.</li>
<li>case 2: there are at most <span class="math inline">\(n^{3/2}\)</span> real solutions. Then it remains to count the contribution of fake pseudo-solutions to the triangle count. But observe, <span class="math inline">\(\Pr[h(a+b+c)=0] = 1/n^{3/2}\)</span> so long as <span class="math inline">\(a+b+c\neq 0\)</span>. Hence, the expected number of fake pseudo-solutions is <span class="math inline">\(n^{3}/n^{3/2}.\)</span></li>
</ul>
<p>Thus, the number of triangles is <span class="math inline">\(O(n^{3/2})\)</span>, as desired.</p>
<!-- (*if we were doing the pentagon version instead this would look as -->
<!-- follows: there are at most $n^{4}/|G'|^{5}$ fake solutions in -->
<!-- expectation. then we do two cases: lots of real solutions in -->
<!-- which case we just win and very few real solutions in which case -->
<!-- they don't contribute much to the pseudo solutions.*) -->
<p><strong>claim 3:</strong> counting cycles</p>
<p>For simplicity we assume <span class="math inline">\(A \cap -A = \varnothing\)</span>, this just simplifies the labelling scheme and is not necessary.</p>
<p>Now we bound the number of <span class="math inline">\(C_4\)</span>’s. Fix some ordering of the parts as “clockwise”. We classify a <span class="math inline">\(C_4\)</span> with labels <span class="math inline">\(\pm a_1,\pm a_2,\pm a_3,\pm a_4\)</span> (The <span class="math inline">\(\pm\)</span>-ness is determined by the orientation) into two types:</p>
<ol type="1">
<li>pseudo-cycle: <span class="math inline">\(\sum a_i \neq 0\)</span>. We will arguge that there cannot be too many of these due to independence.</li>
<li>zero-cycle: <span class="math inline">\(\sum a_i = 0\)</span>. We can’t use independence here. Fortunately, additive energy gives the bound instead!</li>
</ol>
<p>claim 3.1: <strong>Rate of zero-cycles:</strong> Let <span class="math inline">\(a_1,a_2,a_3,a_4\)</span> be a set of vectors summing to <span class="math inline">\(0\)</span>, spanning a space of dimension <span class="math inline">\(s\le 3\)</span>. Then probability of a cycle with labels <span class="math inline">\(a_1,a_2,a_3,a_4\)</span> containing some specific vertex is at most <span class="math inline">\(|G&#39;|^{-s}\)</span>.</p>
<p>proof: simple inductive argument. either you add a new linearly independent vector in which case you get a new constraint that hits your probability with a <span class="math inline">\(|G&#39;|^{-1}\)</span>, or else you get a linearly dependent vector, in which case it can’t have helped your probability.</p>
<p>claim 3.2: <strong>rate of pseudo-cycles</strong>: Fix vertex <span class="math inline">\(v\)</span> and <span class="math inline">\(a_1,a_2,a_3, a_4 \in \pm A\)</span> with <span class="math inline">\(\sum a_i \neq 0.\)</span> Then, there is a cycle starting from <span class="math inline">\(v\)</span> labelled with <span class="math inline">\(a_1,a_2,a_3,a_4\)</span> with probability at most <span class="math inline">\(|G&#39;|^{-s-2}\)</span> where <span class="math inline">\(s = \dim\langle a_1,\ldots, a_4 \rangle\)</span>.</p>
<p>proof: It’s basically the same proof as the previous zero-cycles, except we get a boost in the base case. (it is actually convenient for their induction to consider the probability that <span class="math inline">\(h(a_0)=0\)</span> and “there is a <span class="math inline">\(a_1,a_2,\ldots, a_k\)</span> walk starting from <span class="math inline">\(v\)</span>” and define <span class="math inline">\(s = \dim (a_0,a_1,\ldots, a_k)\)</span>). <!-- *(remark: this stuff seems to work pretty similarly in the --> <!-- pengaton case. should would get $|G'|^{-s-4}$ in the --> <!-- pseudo-cycles rate. Let the record show that I'm a little bit --> <!-- worried about cycles of length shorter than $6$ / if the pentagon --> <!-- thing makes any sense.)* --> (remark: they do all this also banning longer cycles and stuff)</p>
<p>claim 3.3: combining the previous two claims to bound the number of cycles:</p>
<p>First we count the expected number of pseudo-cycles: <span class="math display">\[\sum_{a_1,\ldots, a_k\in \pm A \mid a_1+\cdots+a_k\neq 0} \sum_{v\in V} \Pr[\text{cycle containing v labelled } a_1,\cdots,a_k].\]</span> We break the sum up by <span class="math inline">\(\dim(a_1,\cdots,a_k)\)</span>. And then we bound the number of <span class="math inline">\(s\)</span>-dimensional spaces by <span class="math inline">\(n^{s}\)</span>. Size of <span class="math inline">\(V\)</span> is <span class="math inline">\(|G&#39;|^{3-1}\)</span> here. Overall we get: <span class="math display">\[O(n^{k}|G&#39;|^{-k}).\]</span></p>
<p>Now we bound the number of zero-cycles, using our bound on additive energy.</p>
<!-- **NOTE: I don't see how to get the pentagon version working**  -->
<p><strong>claim 4:</strong> degree regularization Observe: The expected degree of each vertex is <span class="math inline">\(\Theta(\sqrt{n})\)</span>: for each <span class="math inline">\(a\in A\)</span> there is a <span class="math inline">\(1/\sqrt{n}\)</span> chance that <span class="math inline">\(h(a)=-x_2\)</span> or whatever. It turns out the variance of the degree is <span class="math inline">\(O(\sqrt{n})\)</span>. Thus, we can do the following algorithm: Kick out high degree and low degree vertices. After not too long everyone has degree that is <span class="math inline">\(\Theta(\sqrt{n})\)</span>.</p>
<p><strong>claim 5:</strong> put it all together</p>
<p><strong>TODO: understand this one more!</strong></p>
</div>
<h1 id="energy-reduction-amplification">energy reduction amplification</h1>
<div class="rmk envbox">
<p><strong>Remark.</strong> The Jin, Xu paper shows how to actually get a Sidon set, i.e., a set with the absolute minimum additive energy. Abboud et al only show how to obtain a set with <span class="math inline">\(O(n^{2.0001})\)</span> additive energy. The Jin Xu result seems pretty cool, but the results are equaly good for our applications. I think the Abboud one is a bit simpler so I will present theirs.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> <strong>HASHING!!!!!</strong></p>
<p>Use some hash functions to subsample your instance. Basically in Abboud et al ’s language this is just some random projection.</p>
<p>Intuitively, slicing up the instance kills additive energy faster than it kills 3sum solutions. So the little boost that we started with is enough that we can win here.</p>
<p><strong>TODO: understand more.</strong></p>
</div>
<h1 id="energy-reduction-initial">energy reduction initial</h1>
<div class="pf envbox">
<p><strong>Proof.</strong></p>
<p><strong>Claim 1</strong>: (tripartite) 3SUM is easy if one of the sets has bounded doubling.</p>
<p>proof: For sake of intuition, think of the set <span class="math inline">\(A\)</span> as being contained in a small interval <span class="math inline">\(I\)</span> (In general, <span class="math inline">\(A\)</span> is contained densely in some “approximate group”).</p>
<p>Partition <span class="math inline">\(B,C\)</span> into <span class="math inline">\(B_1,B_2,\ldots,\)</span> and <span class="math inline">\(C_1,C_2,\ldots\)</span> by covering them with disjoint translates of <span class="math inline">\(A\)</span>.</p>
<p>Call <span class="math inline">\((i,j)\)</span> <strong>relevant</strong> if it could possibly be the case that <span class="math inline">\(A+B_i \cap -C_j \neq \varnothing\)</span> just based on the intervals that are covering the dudes. Observe that <span class="math inline">\(A+B_i\)</span> is contained in a small interval, so it only intersects <span class="math inline">\(O(1)\)</span> <span class="math inline">\(C_j\)</span>’s. Then we do the following:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="cf">for</span> relevant i,j:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  <span class="cf">if</span> Bi <span class="kw">and</span> Cj are both small (size smaller than n<span class="op">^</span>{<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>}):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    brute force check <span class="cf">if</span> there <span class="kw">is</span> <span class="bu">any</span> b <span class="kw">in</span> Bi <span class="kw">and</span> c <span class="kw">in</span> Cj <span class="cf">for</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    which b<span class="op">+</span>c <span class="kw">in</span> <span class="op">-</span>A</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="cf">else</span> <span class="cf">if</span> one of Bi, Cj <span class="kw">is</span> large:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    Use FFT to compute Bi <span class="op">+</span> Cj. Then check <span class="cf">if</span> Bi <span class="op">+</span> Cj has</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    non<span class="op">-</span>empty intersection <span class="cf">with</span> <span class="op">-</span>A</span></code></pre></div>
<p>Run time:</p>
<ul>
<li>light: <span class="math inline">\(n\cdot n^{2/3}\)</span> (<span class="math inline">\(n\)</span> many, <span class="math inline">\(n^{2/3}\)</span> brute cost)</li>
<li>heavy: <span class="math inline">\(n\log n\cdot n^{2/3}\)</span> (<span class="math inline">\(n^{2/3}\)</span> many, <span class="math inline">\(n\)</span> fourier cost)</li>
<li>total: <span class="math inline">\(\widetilde{O}(n^{5/3})\)</span>.</li>
</ul>
<p><strong>TODO: talk about Ruzsa covering lemma, and just generally how you do this</strong></p>
<p>Now that we have claim 1, we give the following algo for the initial energy reduction:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="cf">while</span> additive energy <span class="op">&gt;</span> n<span class="op">^</span>{<span class="fl">2.999</span>}:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  A<span class="st">&#39; = use BSG to peel off a set with bounded doubling</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="st">  check if A&#39;</span> <span class="kw">is</span> useful <span class="cf">for</span> <span class="bu">any</span> 3SUM solutions using the fast</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  bounded doubling 3sum algo.</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  <span class="cf">if</span>: </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>    so, <span class="cf">return</span> the found solution</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>  <span class="cf">else</span>:</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>    Evict A<span class="st">&#39; and keep going</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a><span class="st">if size is really small: </span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a><span class="st">  brute force solve</span></span></code></pre></div>
<p><strong>Claim 2:</strong> As long as the additive energy is larger than <span class="math inline">\(n^{2.999}\)</span> we almost certainly can do the peeling off step and its probably fast. So, either the size gets too small in which case we can afford to just brute force and find a solution, or if not then we have reduced to a reasonable 3sum instance just with slightly subcubic additive energy.</p>
<p><strong>TODO: argue more formally that this works. </strong></p>
</div>
