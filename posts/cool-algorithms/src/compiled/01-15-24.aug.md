\newcommand{\one}{\mathbbm{1}}
\newcommand{\bigO}{\mathcal{O}}
\DeclareMathOperator{\E}{\mathbb{E}}
\DeclareMathOperator{\Var}{\text{Var}}
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\Id}{Id}
\DeclareMathOperator{\img}{Img}
\DeclareMathOperator{\polylog}{\text{polylog}}
\DeclareMathOperator{\poly}{\text{poly}}
\newcommand{\st}{\text{ such that }}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\interior}[1]{ {\kern0pt#1}^{\mathrm{o}} }
\newcommand{\mb}{\mathbf}
\newcommand{\partition}{\vdash}
\newcommand{\x}{\mathbf{x}}
\newcommand{\y}{\mathbf{y}}
\newcommand{\z}{\mathbf{z}}
\newcommand{\eps}{\varepsilon}
\renewcommand{\d}{\mathrm{d}}
\renewcommand{\Re}{\mathrm{Re}}
\renewcommand{\Im}{\mathrm{Im}}

\newcommand{\setof}[2]{\left\{ #1\; : \;#2 \right\}}
\newcommand{\set}[1]{\left\{ #1\right\}}

\newcommand{\R}{\mathbb{R}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\contr}{\[ \Rightarrow\!\Leftarrow \]}
\newcommand{\defeq}{\vcentcolon=}
\newcommand{\eqdef}{=\vcentcolon}

\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\paren}[1]{\left( #1 \right)}
\newcommand{\ang}[1]{\langle #1 \rangle}
\newcommand{\abs}[1]{\left| #1 \right|}


# 7.4 monadic logic on graphs

They define a certain logic on graphs. 
Let's just write some examples.

<div class="ex envbox">**Example.**

**partition**: given three vertex subsets, are they a partition
of the vertices of the graph?

$$\text{partition}(X_1,X_2,X_3) = \forall_{v\in V} v\in X_1 \lor v\in X_2 \lor v\in X_3.$$

**indep**: given a vertex subset, is it an independent set?

$$\text{indep}(X) = \forall_{u,v \in X} uv\notin E.$$


**3COLOR**: is my graph three colorable?

$$\exists_{X_1,X_2,X_3 \subseteq V} \text{partition}(X_1,X_2,X_3) \land \text{indep}(X_1) \land \text{indep}(X_2) \land \text{indep}(X_3).$$

</div>

<div class="thm envbox">**Theorem.**
Courcelle's theorem:

Let $G$ be a graph with tree width $t$, and let $\varphi$ be a
formula in monadic second-order logic. Then, there is an
algorithm that determines whether $\varphi$ is satisfied on  $G$
in runnning time $f(||\varphi||, t)\cdot n$ for a computable
function  $f$.
</div>

<div class="rmk envbox">**Remark.**
We can't give good bounds on $f$: if you alternate quantifiers a
lot it can be really really really massive. Like much worse than tower.
So this is more of a "if your problem is like this then its FPT"
than the final word on parameterization by tree-width.
</div>

The following optimization version of Courcelle's theorem is also
useful, e.g., for vertex cover, where it's not clear how to get a
monadic formula thing that doesn't have a $k$ dependence.

<div class="thm envbox">**Theorem.**
If you have a formula and a pretty nice function you want to
optimize, that's FPT in $||\varphi||$ and tree-width too.
</div>

# other interpretations of tree-width

## path-width

<div class="thm envbox">**Theorem.**
The following graph parameters are basically (up to a dumb $\pm 1$) equivalent:

- node-search number
- interval width
- path width

</div>

Here is a hypothetical story (not real life) to explain
node-search number.

Blobby is on the run from the cops. Luckily Blobby is omniscient
and has unbounded speed.
He's also invisible!
Unforunately for him, the cops are
really out to get him. They know his weakness: each of the cops
has a box of pizza. If Blobby ever occupies the same vertex as a
cop he will be sucked into the box of pizza.
The cops start wherever and at each step you can do a **place**
move: take a cop from the pool of unplaced cops and place it, 
or you can do a **extract** move: take a cop from the graph and
put them into the unused cops pool.

The node-search number of a graph is the fewest number of cops
needed to catch Blobby.

Here's a picture that I think helps see why node-search number is
related to interval width / path width:

![ink_img011](src/images/ink_img011.png)

It might be hard to think of Blobby as being omniscient,
unbounded speed and invisible. Instead, you can think of Blobby
as being a gas that the cops are cleaning up. If there is gas on
an edge it will spread to any edges that share a vertex with it,
unless that vertex is blocked by a cop. If cops occupy both
endpoints of an edge then the gas dies in that edge. But of
course edges can be recontaminated.

## tree-width

Somewhat similar story for tree-width.

Key difference: cops can see the Blobby in the tree chase
version. And cops have to announce their next move, and Blobby
gets to choose where to go after the cops announce move. 

**bramble**: a collection of pairwise touching connected vertex subsets. 
(We say that two vertex subsets are *touching* if they share a
vertex or if there is an edge between them).

<div class="thm envbox">**Theorem.**
treewidth $k$ iff bramble of order $k+1$.
</div>
<div class="pf envbox">**Proof.**
one direction pretty clear, other apparently very tricky.
</div>

<div class="defn envbox">**Definition.**
cordal graph:
Largest induced cycle is a triangle.

cordal width: min max-clique in a chordal super graph.

</div>

<div class="thm envbox">**Theorem.**

TFAE up to $\pm 1$

- treewidth
- chordal width
- max bramble
- cops to catch visible robber

</div>

# computing treewidth

unforunately tree-width exactly NP-hard. But we can settle for
FPT algo / approx algo.

<div class="defn envbox">**Definition.**
$H$ is a minor of $G$ if you can obtain $H$ from $G$ by some
combination of deleting vertices, edges, and contracting edges.
</div>

<div class="rmk envbox">**Remark.**
Apparently you can efficiently test if a constant size graph is a
minor of your graph. In like $n^{3}$ time. No idea how.
</div>

<div class="thm envbox">**Theorem.**
MEME FPT algorithm for computing treewidth (i.e., determining
whether treewidth is larger than $k$ or not).
</div>
<div class="pf envbox">**Proof.**

tree-width is **minor monotone**: taking minors only decreases
tree-width. Hence, the set of graphs with tree-width at most $k$
is closed under taking minors. Hence, there is a set of forbidden
minors, whose size depends only on $k$, such that a graph has
tree-width at most $k$ iff it avoids the forbidden minors.

Thus, to check if a graph has tree-width at most $k$ you just
check for each of the forbidden minors whether it is a minor of
your graph.

This is not such a useful algorithm maybe because determining the
set of forbidden minors seems really hard, and that set is going
to be freaking massive.

</div>

<div class="rmk envbox">**Remark.**
Ok there is also an actual (uniform) algorithm. with run time
$k^{k^{3}} \cdot n$. 

But this is a bit slow, so we're gonna just do an approx algo
instead.
</div>

<div class="thm envbox">**Theorem.**
There is a $8^{k}k^{2}n^2$ algo that either constructs a tree
decomposition of widdth at most $4k+4$ or outputs (correctly)
that $G$ has treewidth larger than $k$.

Ok, more recently:
There is a $2^{O(k)}\cdot n$ algo that either constructs a tree
decomposition of widdth at most $5k+5$ or outputs (correctly)
that $G$ has treewidth larger than $k$.

Anyways, we're gonna prove the easier version. 
But it's looking pretty intense, so prolly has to wait till after
lunch.
</div>
<div class="pf envbox">**Proof.**

TODO
</div>

