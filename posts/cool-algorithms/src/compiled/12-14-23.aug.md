\newcommand{\one}{\mathbbm{1}}
\newcommand{\bigO}{\mathcal{O}}
\DeclareMathOperator{\E}{\mathbb{E}}
\DeclareMathOperator{\Var}{\text{Var}}
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\Id}{Id}
\DeclareMathOperator{\img}{Img}
\DeclareMathOperator{\polylog}{\text{polylog}}
\DeclareMathOperator{\poly}{\text{poly}}
\newcommand{\st}{\text{ such that }}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\interior}[1]{ {\kern0pt#1}^{\mathrm{o}} }
\newcommand{\mb}{\mathbf}
\newcommand{\partition}{\vdash}
\newcommand{\x}{\mathbf{x}}
\newcommand{\y}{\mathbf{y}}
\newcommand{\z}{\mathbf{z}}
\newcommand{\eps}{\varepsilon}
\renewcommand{\d}{\mathrm{d}}
\renewcommand{\Re}{\mathrm{Re}}
\renewcommand{\Im}{\mathrm{Im}}

\newcommand{\setof}[2]{\left\{ #1\; : \;#2 \right\}}
\newcommand{\set}[1]{\left\{ #1\right\}}

\newcommand{\R}{\mathbb{R}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\contr}{\[ \Rightarrow\!\Leftarrow \]}
\newcommand{\defeq}{\vcentcolon=}
\newcommand{\eqdef}{=\vcentcolon}

\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\paren}[1]{\left( #1 \right)}
\newcommand{\ang}[1]{\langle #1 \rangle}
\newcommand{\abs}[1]{\left| #1 \right|}


# triangle detection to triangle finding
Randomly split vertices in half. Run detection on both halves. 
Have to try $O(1)$ times in expectation. 
The run time would be, in expectation, 
$$\sum T(n/2^{i})\le T(n) 2\sum (1-\eps)^{i}\le T(n)2\eps^{-1}.$$

This can be de-randomized as follows: 
split the set into $6$ equal sized parts. There must be some set
of $3$ of them that contains a triangle. Every set of $3$ of them
has size $n/2.$


# using triangle detection to do BMM

BMM is defined as 
$$(AB)[i,j] = \bigvee_k (A[i,k]\land B[k,j]).$$

<div class="rmk envbox">**Remark.**
You can do BMM via fast MM techniques in $n^{\omega}$ time.
</div>

<div class="thm envbox">**Theorem.**
You can also do BMM via triangle-detection.
This is asymptotically slower, but kind of nicer because it
doesn't rely on crazy impractical tensor-decomposition stuff with
ridiculous constant factors. 
More precisely, 
if there is a $D(n)$ time algorithm for triangle detection then
there is an $n^{2}D(n^{1/3})$ time algorithm for BMM.
Using BMM to do triangle detection is trivial. 
Thus, BMM and triangle detection are "sub-cubic equivalent".
</div>
<div class="pf envbox">**Proof.**
Make a tri-partite graph $X,Y,Z$.
Put all the edges between $X,Z$. 
Put edges between $i\in X,j\in Y$ if $A[i,j]=1$
and edges between  $j\in Y, k\in Z$ if  $B[j,k]=1$.

Split each of $X,Y,Z$ into parts of size $t$.
For each tripple of little parts eat all the triangles in it. 

Run time: 
$$t^3 D(n/t) + n^{2} D(n/t).$$
Set $t=n^{2/3}$.
</div>
