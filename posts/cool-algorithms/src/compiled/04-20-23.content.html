<p>for <span class="math inline">\(d|n\)</span>, for <span class="math inline">\(x\in \left\{ 0,1\right\}^d\)</span>, make sure <span class="math inline">\(x\)</span> isn’t <span class="math inline">\(k\)</span>-periodic for any <span class="math inline">\(k|d, k&lt; d\)</span>; this can be done in linearithmic time because it suffices to check for <span class="math inline">\(p|d\)</span> which is distinct prime divisors, and each such check requires linear time.</p>
<p>Now, you might ask, what the running time is. It is of course <span class="math display">\[\sum_{d|n} 2^d d\log d\]</span></p>
<p>Now, is this actually better than just generating all binary strings of length <span class="math inline">\(n\)</span> and then for each pair, checking if they are rotated copies of one another? of course! that’s like <span class="math inline">\(\Omega(4^n)\)</span>. This should be more like <span class="math inline">\(O(2^n n^2)\)</span> or something… (I haven’t been able to do the sum yet, but whateves.)</p>
<p><strong>it has been noted that it is possible to do this much faster and simpler with using hash tables; but can we beat</strong> <span class="math inline">\(O(2^n)\)</span>? i kind of doubt it</p>
<p>Now you might ask, what if I want to also rule out reflectional symmetry and rotoation + reflectional symmetry ?</p>
<p>you might also ask is it possible to check rotational / roto-reflectional symmetry faster than <span class="math inline">\(n^2\)</span> time?</p>
<p>to be continued after pickelball</p>
