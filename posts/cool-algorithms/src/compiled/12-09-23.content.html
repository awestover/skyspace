<p>The topic today is taken from <a href="https://people.csail.mit.edu/virgi/6.890/">Virginia Williams’ MM + Graph Algs lecture notes</a>. Throughout the post <span class="math inline">\(\omega&lt;2.4\)</span> is the matrix multiplication exponent. MM will stand for matrix multiplication.</p>
<h1 id="cycles-versus-triangles">Cycles versus triangles</h1>
<div class="thm envbox">
<p><strong>Theorem.</strong> Let <span class="math inline">\(k\in \mathbb{N}_{\ge 3}\)</span> be a constant. directed/undirected-<span class="math inline">\(k\)</span>-cycle detection can be accomplished in <span class="math inline">\(n^{\omega}\)</span> time on <span class="math inline">\(n\)</span>-vertex graphs.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> It suffices to prove the theorem for directed graphs. We won’t need to explicitely mention this throughout the proof, but just note that the adjacency matrices needn’t be symmetric.</p>
<p>For <span class="math inline">\(k=3\)</span> you can just cube the adjacency matrix and check whether its trace is <span class="math inline">\(0\)</span>. This doesn’t work for <span class="math inline">\(k&gt;3\)</span> because powers of the adjacency matrix count walks, i.e., are allowed to repeat vertices.</p>
<p>Instead we do color coding! Color with <span class="math inline">\(k\)</span> colors. Make matrices <span class="math inline">\(A_1,A_2,\ldots, A_{k-1}\)</span> where <span class="math inline">\(A_i\)</span> represents the transition from color <span class="math inline">\(i\)</span> vertices to color <span class="math inline">\(i+1\)</span> vertices. That is, fix some ordering of the vertices within each color class, and then make the rows of <span class="math inline">\(A_i\)</span> be the vertices of color <span class="math inline">\(i\)</span> and the columns of <span class="math inline">\(A_i\)</span> be the vertices of color <span class="math inline">\(i+1\)</span>, and place edges if the vertices are adjacent.</p>
<p>Let <span class="math inline">\(B = A_1\cdot A_2\cdots A_{k-1}\)</span>; <span class="math inline">\(B\)</span> can be computed in <span class="math inline">\(n^{\omega}\)</span> time. <span class="math inline">\(B[u,v]\)</span> counts the number of <span class="math inline">\(k\)</span>-vertex paths from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span> whose vertices are colors <span class="math inline">\(1,2,\ldots, k\)</span>.</p>
<p>Now, for each <span class="math inline">\(u,v\)</span> check whether <span class="math inline">\(A[v,u]=1 \land B[u,v]&gt;0\)</span>. If the check ever passes then we have found a <span class="math inline">\(k\)</span>-cycle.</p>
<p>If the cycle was correctly colored we must find a <span class="math inline">\(k\)</span>-cycle in this manner.</p>
<p>The coloring succeeds with probability <span class="math inline">\(\frac{1}{k^{k}}\ge \Omega(1)\)</span>. Taking <span class="math inline">\(\Omega(\log n)\)</span> tries for the coloring lets us succeed at least once with high probability.</p>
<figure>
<img src="src/images/graph1.png" alt="" /><figcaption>src/images/graph1.png</figcaption>
</figure>
</div>
<blockquote>
<p>Is this tight? Turns out it is for odd cycles but not for even.</p>
</blockquote>
<div class="thm envbox">
<p><strong>Theorem.</strong> “Even cycles Even Faster”</p>
<ol type="1">
<li>For all <span class="math inline">\(k\)</span>, there is an <span class="math inline">\(n^{2}\)</span> algorithm to detect existence of a <span class="math inline">\(2k\)</span> cycle (and find it, if it exists).</li>
<li>There is an <span class="math inline">\(n^{2}\)</span> time algorithm to find the shortest even cycle.</li>
</ol>
</div>
<p>First I present two simple proofs of the theorem for <span class="math inline">\(k=2\)</span>. Then I’ll present a proof for general <span class="math inline">\(k\)</span>.</p>
<div class="pf envbox">
<p><strong>Proof.</strong> 1. Common neighbor(x,y): make an <span class="math inline">\(n \times n\)</span> matrix <span class="math inline">\(A\)</span>. <span class="math inline">\(A[i,j]\)</span> will store whether we have found a common neighbor for <span class="math inline">\(i,j\)</span> so far. If any cell in the matrix ever gets hit twice then we found a <span class="math inline">\(4\)</span>-cycle.</p>
<p>What we do is, for each vertex <span class="math inline">\(v\)</span>, for each pair of vertices in <span class="math inline">\(N(v)\)</span> mark them as having a common neighbor.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> 2. wlog its bipartite: In particular, take <span class="math inline">\(G=(V,E)\)</span>, and form <span class="math inline">\(G&#39;\)</span> by duplicating the vertex set to <span class="math inline">\(V\sqcup V&#39;\)</span> and put an edge between <span class="math inline">\(uv&#39;\)</span> if <span class="math inline">\(uv\)</span> is an edge in <span class="math inline">\(G\)</span>. Then, if you had a <span class="math inline">\(4\)</span>-cycle in <span class="math inline">\(G\)</span> it is converted into a <span class="math inline">\(4\)</span>-cycle in <span class="math inline">\(G&#39;\)</span>. But of course <span class="math inline">\(G&#39;\)</span> is bipartite and only a constant-factor larger. Then, run BFS-cycle out of each vertex (for depth <span class="math inline">\(2\)</span>). This must terminate fast. More precisely, for all vertices in the neighbor-set of one of your vertices color their left-neighbors. If a left-neighbor gets colored twice it means you have a <span class="math inline">\(C_4\)</span>.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> goal: check whether our graph contains a <span class="math inline">\(2k\)</span>-cycle Note: wlog <span class="math inline">\(m\le 200 n^{1+\frac{1}{k}}\)</span> or else we are guaranteed to have a <span class="math inline">\(2k\)</span>-cycle (even, super-saturation of <span class="math inline">\(2k\)</span>-cycles. anyways, we can find them.)</p>
<p><strong>Case 1:</strong> There exists a high degree vertex, say with degree larger than <span class="math inline">\(H\)</span> somewhere on the cycle. There aren’t so many vertices like this. It costs <span class="math inline">\(\frac{m}{H} n\)</span> to just BFS-cycle out of all the high degree vertices.</p>
<p><strong>Case 2</strong>: Negation of case 1. i.e., all vertices on the cycle have degree smaller than <span class="math inline">\(H\)</span>. Then we can do BFS-cycle a bit more efficiently, in time <span class="math inline">\(n H^{k}\)</span>.</p>
<p>Balancing (1) and (2) gives:</p>
<p><span class="math display">\[ \frac{m}{H}n = nH^{k} \implies H = m^{1/(k+1)}.\]</span></p>
<p>This yields running time <span class="math display">\[n m^{k/(k+1)} \le n n^{(1+1/k)(k/(k+1))} = n^{2}.\]</span></p>
</div>
<p>Now I establish that odd cycle detection does require <span class="math inline">\(n^{\omega}\)</span> time. First we prove another interesting result:</p>
<div class="thm envbox">
<p><strong>Theorem.</strong> Let <span class="math inline">\(k\)</span> be an odd constant. Then directed-<span class="math inline">\(k\)</span>-cycle is equivalently hard to undirected-<span class="math inline">\(k\)</span>-cycle.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> We can convert an instance of undirected-<span class="math inline">\(k\)</span>-cycle to directed-<span class="math inline">\(k\)</span>-cycle by thinking of each edge <span class="math inline">\(\left\{ u,v\right\}\)</span> as being two directed edges <span class="math inline">\(u\to v\)</span> and <span class="math inline">\(v\to u\)</span>.</p>
<p>The other direction is more subtle. We are given an instance of directed-<span class="math inline">\(k\)</span>-cycle. By color coding we assume that the graph has parts <span class="math inline">\(V_1,V_2,\ldots, V_k\)</span> and we only consider edges from <span class="math inline">\(V_i\to V_{i+1}\)</span>. Let this new graph be <span class="math inline">\(G&#39;\)</span>.</p>
<p>Let <span class="math inline">\(G&#39;&#39;\)</span> be the graph obtained by dropping the directionality on the edges in <span class="math inline">\(G&#39;\)</span>.</p>
<p><strong>Claim</strong>: <span class="math inline">\(G&#39;&#39;\)</span> has an undirected-<span class="math inline">\(k\)</span>-cycle iff colorful <span class="math inline">\(G&#39;\)</span> has a directed <span class="math inline">\(k\)</span>-cycle.</p>
<p>Proof of claim: If <span class="math inline">\(G&#39;\)</span> has a cycle then dropping the directionality won’t kill the cycle. If the cycle in <span class="math inline">\(G&#39;&#39;\)</span> uses a vertex from each of the <span class="math inline">\(k\)</span> parts <span class="math inline">\(V_i\)</span> then it is clearly a cycle in <span class="math inline">\(G&#39;\)</span>. Assume for contradiction that there is a cycle in <span class="math inline">\(G&#39;&#39;\)</span> that doesn’t use some part <span class="math inline">\(V_i\)</span>. But <span class="math inline">\(G&#39;&#39;\setminus V_i\)</span> is bipartite, so it cannot contain an odd cycle.</p>
<figure>
<img src="src/images/graph2.png" alt="" /><figcaption>Depictionn of the layered grahp</figcaption>
</figure>
<figure>
<img src="src/images/graph3.png" alt="" /><figcaption>Why this breaks if k is even</figcaption>
</figure>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> Let <span class="math inline">\(k\)</span> be a constant. Directed-<span class="math inline">\(k\)</span>-cycle is equivalently hard to triangle detection.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> We already showed how to solve directed-<span class="math inline">\(k\)</span>-cycle with MM.</p>
<p>Let <span class="math inline">\(G = (V, E)\)</span> be a graph we want to do triangle detection in. Make <span class="math inline">\(k\)</span> copies of the vertex set: <span class="math inline">\(V_1,V_2,\ldots, V_k\)</span>. We denote the copies of a vertex <span class="math inline">\(v\)</span> by <span class="math inline">\(v_1,v_2,\ldots, v_k\)</span>.</p>
<ul>
<li><p>Connect <span class="math inline">\(u_1\to v_2 \in V_1 \times V_2\)</span> iff <span class="math inline">\((u,v)\in E(G)\)</span>.</p></li>
<li><p>Connnect <span class="math inline">\(u_k\to v_1 \in V_{k}\times V_1\)</span> iff <span class="math inline">\((u,v) \in E(G)\)</span></p></li>
<li><p>For each <span class="math inline">\(i\in [2, k-1]\)</span> and each vertex <span class="math inline">\(v\in V\)</span> connect <span class="math inline">\(v_i\to v_{i+1}\in V_i \times V_{i+1}\)</span>.</p>
<p>A <span class="math inline">\(k\)</span>-cycle in this new graph corresponds to a triangle in the original graph.</p></li>
</ul>
</div>
<h1 id="girth">Girth</h1>
<p><strong>GIRTH</strong>: length of shortest cycle</p>
<h3 id="approx-in-n1.5-time"><span class="math inline">\(2\)</span>-approx in <span class="math inline">\(n^{1.5}\)</span> time</h3>
<div class="rmk envbox">
<p><strong>Remark.</strong> In “New Subquadratic Approximation Algorithms for the Girth” Knudsen talks about Virginia and Roditty’s paper. He observes that her algorithm outputs a cycle of size <span class="math inline">\(2\left\lceil g/2 \right\rceil + 2\left\lceil g/4 \right\rceil\)</span> when the girth is <span class="math inline">\(g\)</span>. So technically for <span class="math inline">\(g=3\)</span> this is a <span class="math inline">\(2\)</span>-approx. But for larger values of <span class="math inline">\(g\)</span> it is essentially a <span class="math inline">\(1.5\)</span>-approx. And her algo is indeed <span class="math inline">\(n^{5/3}\)</span>.</p>
<p>Note: Knudsen gives a sub-quadratic algorithm that, if the girth is <span class="math inline">\(g\)</span>, returns a cycle with size at most <span class="math display">\[2\left\lceil g/2 \right\rceil+2\left\lceil \frac{g}{2(k-1)} \right\rceil\le (1+\varepsilon)g + 3,\]</span> for suitably large <span class="math inline">\(k\)</span>, although the run time is of course <span class="math inline">\(n^{2-1/k}\)</span>.</p>
<p>So I feel like the barrier to an <span class="math inline">\(o(n^{2})\)</span> <span class="math inline">\((2-\varepsilon)\)</span>-approx is really “given a graph with girth <span class="math inline">\(3\)</span>, can you find any of a triangle, a square, or a pentagon in subquadratic time?”</p>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> There is an algorithm that, given an <span class="math inline">\(n\)</span>-vertex graph <span class="math inline">\(G\)</span> with girth <span class="math inline">\(g\ge 3\)</span> outputs a cycle of length at most <span class="math display">\[2\left\lceil g/2 \right\rceil+2\left\lceil g/4 \right\rceil\le 2g,\]</span> in running time <span class="math inline">\(n^{5/3}\)</span>.</p>
</div>
<div class="rmk envbox">
<p><strong>Remark.</strong> If you want to turn the decision problem stated above into actually an algorithm for finding the shortest cycle, then you can do the standard binary search trick.</p>
</div>
<hr />
<div class="pf envbox">
<p><strong>Proof.</strong> <strong>CAUTION</strong> I have not been especially careful with the floors and ceilings in this proof. They are really important if you care about small <span class="math inline">\(g\)</span>! Beware.</p>
<p>Let <span class="math inline">\(C\)</span> be a length <span class="math inline">\(g\)</span> cycle in <span class="math inline">\(G\)</span>. Call a ball <strong>huge</strong> if it has size larger than <span class="math inline">\(n^{1/3}\)</span>.</p>
<p><strong>Case 1:</strong> Some vertex <span class="math inline">\(v\in C\)</span> has a huge <span class="math inline">\(t\)</span>-radius ball, for some <span class="math inline">\(t\le \left\lceil g/4 \right\rceil\)</span>. Then, if we randomly sample a subset <span class="math inline">\(S\)</span> of size <span class="math inline">\(n^{2/3}\log n\)</span> we intersect with <span class="math inline">\(B\)</span> with high probability. Imagine we ran BFS-cycle out of <span class="math inline">\(y\in B\)</span>. Then we would find a cycle of length at most <span class="math inline">\(g+2t \le 2g\)</span>. So what we do is run BFS-cycle out of all the points in <span class="math inline">\(S\)</span>. The cost of this is <span class="math inline">\(n^{2/3} \cdot n\le n^{5/3}\)</span>.</p>
<p><strong>Case 2:</strong> No vertices on the cycle have huge <span class="math inline">\(\left\lceil g/4 \right\rceil\)</span>-radius balls. Sort the vertices in the graph as <span class="math inline">\(v_1,v_2,\ldots, v_n\)</span> based on how fast their ball gets huge, i.e., the smallest <span class="math inline">\(k\)</span> such that their radius-<span class="math inline">\(k\)</span> ball is huge. In particular, make it so that <span class="math inline">\(v_1\)</span>’s ball becomes huge the slowest and <span class="math inline">\(v_n\)</span>’s ball becomes huge the fastest. Let <span class="math inline">\(H_k\)</span> denote the induced subgraph on <span class="math inline">\(v_1,v_2,\ldots, v_k\)</span>.</p>
<p>We do a BFS-Cycle from vertex <span class="math inline">\(k\)</span> in <span class="math inline">\(H_k\)</span> for each <span class="math inline">\(k\)</span>, except we stop once we have visited <span class="math inline">\(n^{2/3}\)</span> vertices. Let <span class="math inline">\(k_0\)</span> be the first index when all vertices of <span class="math inline">\(C\)</span> are contained in <span class="math inline">\(H_{k_0}\)</span>. We claim that doing this limited BFS in <span class="math inline">\(H_{k_0}\)</span> will find a cycle of length at most <span class="math inline">\(2g\)</span>.</p>
<p>Note that all vertices <span class="math inline">\(v\in H_{k_0}\)</span> satisfy <span class="math inline">\(|B(v, \left\lceil g/4 \right\rceil)| \le n^{1/3}\)</span> and thus <span class="math inline">\(|B(v, 2\left\lceil g/4 \right\rceil)|\le n^{2/3}\)</span>. Thus the BFS-cycle out of <span class="math inline">\(k_0\)</span> will successfully find a cycle of length like at most <span class="math inline">\(4\left\lceil g/4 \right\rceil+1\)</span> ish.</p>
<p>The run time of doing this is going to be <span class="math inline">\(n\cdot n^{2/3}\le n^{5/3}\)</span>.</p>
</div>
<div class="rmk envbox">
<p><strong>Remark.</strong> Virginia gives a somewhat different proof of this in her lecture notes. I’m writing it down too so that I’ll maybe understand it.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong></p>
<p>Let <span class="math inline">\(T_v\)</span> denote the result of BFS-ing out of <span class="math inline">\(v\)</span> until we get <span class="math inline">\(n^{1/3}\)</span> vertices in the tree.</p>
<p>She also starts by BFS-ing out of an <span class="math inline">\((n^{1/3}\log n)\)</span>-sized random set. (Basically. But she also checks that her random set intersects with all the <span class="math inline">\(T_v\)</span>’s. Presumably this happens with high probability? so not sure why she’s checking it.) This handles the case that some vertex in the cycle has a very large <span class="math inline">\(\left\lfloor g/4 \right\rfloor\)</span>-neighborhood.</p>
<p>But she handles the other case a bit differently from Knudsen. Case 2: Each <span class="math inline">\(v\in C\)</span> has a <span class="math inline">\(\left\lfloor g/4 \right\rfloor\)</span> ball of size at most <span class="math inline">\(n^{1/3}\)</span>. In this case we will compute the girth <em>exactly</em>.</p>
<p>Here’s the algorithm:</p>
<ul>
<li>for each <span class="math inline">\(v\)</span>
<ul>
<li>for each pair <span class="math inline">\(x,y \in T_v\)</span>
<ul>
<li>Insert <span class="math inline">\(v, d_{T_v}(x,y), p_{T_v}(x,y)\)</span> into <span class="math inline">\(Q_{x,y}\)</span></li>
</ul></li>
</ul></li>
<li>For each <span class="math inline">\(x,y\)</span> where <span class="math inline">\(Q_{x,y}\)</span> is non-empty:
<ul>
<li>Sort the values in <span class="math inline">\(Q_{x,y}\)</span>’s by distance.</li>
<li>Find <span class="math inline">\(u,v\)</span> such that <span class="math inline">\(d_{T_v}(x,y) + d_{T_u}(x,y)\)</span> is minimized</li>
<li>consider the cycle determined by <span class="math inline">\(x,y,u,v\)</span> as defining the quarters.</li>
</ul></li>
</ul>
</div>
<hr />
<div class="thm envbox">
<p><strong>Theorem.</strong> (Due to Knudsen et al, also from the paper “New Subquadratic Approximation Algorithms for the Girth”.)</p>
<p>There is a (multiplicative) <span class="math inline">\(\mathcal{O}(1)\)</span>-approx for girth with running time <span class="math inline">\(n^{2+1/k}\)</span> for any constant <span class="math inline">\(k\)</span>.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> We present it for <span class="math inline">\(k=5\)</span> for simplicity.</p>
<p>We are going to give a <span class="math inline">\(31\)</span>-approximation or something.</p>
<p>Do each of the following things:</p>
<ul>
<li>Sample a set of <span class="math inline">\(n\)</span> vertices, BFS-Cycle for <span class="math inline">\(n^{1/5}\)</span> steps out of each of them.</li>
<li>Sample a set of <span class="math inline">\(n^{4/5}\log n\)</span> vertices, BFS-cycle for <span class="math inline">\(n^{2/5}\)</span> steps out of each of these vertices.</li>
<li>Sample a set of <span class="math inline">\(n^{3/5}\log n\)</span> vertices, BFS-cycle for <span class="math inline">\(n^{3/5}\)</span> steps out of each of these vertices.</li>
<li>Sample a set of <span class="math inline">\(n^{2/5}\log n\)</span> vertices, BFS-cycle for <span class="math inline">\(n^{4/5}\)</span> steps out of each of these vertices.</li>
<li>Sample a set of <span class="math inline">\(n^{1/5}\log n\)</span> vertices, BFS-cycle for <span class="math inline">\(n^{5/5}\)</span> steps out of each of these vertices.</li>
</ul>
<p>Let <span class="math inline">\(C\)</span> be a minimum length cycle.</p>
<p>Let <span class="math inline">\(r_0\)</span> be the minimum <span class="math inline">\(r&gt;0\)</span> such that <span class="math inline">\(|B(C, \left\lceil g/2 \right\rceil(2^{r}-1))| \le n^{r/5}\)</span>. Then we have that <span class="math inline">\(|B(C, \left\lceil g/2 \right\rceil(2^{r_0-1}-1))| &gt; n^{(r_0-1)/5}\)</span>.</p>
<p>We claim that we will find a pretty short cycle when we run the <span class="math inline">\(r_0\)</span>-th itteration of our for-loop.</p>
<p>By a calculation we find that we will, with high probability, get some vertex <span class="math inline">\(u \in B(C, \left\lceil g/2 \right\rceil(2^{r_0-1}-1))\)</span> in the set of size <span class="math inline">\(n^{\frac{6-r_0}{5})} \log n\)</span> that we sample. Then if we BFS-cycle out of this dude we get the desired short cycle.</p>
</div>
<hr />
<h3 id="a-worse-algorithm">A worse algorithm:</h3>
<div class="prop envbox">
<p><strong>Proposition.</strong> 2-approx in <span class="math inline">\(n^2\)</span> time.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> Let <span class="math inline">\(G=(V, E)\)</span>. form a new graph with vertex sets <span class="math inline">\(V, V&#39;\)</span>. make an edge <span class="math inline">\(xy&#39; \in G&#39;\)</span> for <span class="math inline">\(x\in V, y&#39;\in V&#39; \iff xy\in E(G)\)</span>. So <span class="math inline">\(G&#39;\)</span> is bipartite. claim: If G’ has a cycle of length <span class="math inline">\(k\)</span> then G has a cycle of length at least <span class="math inline">\(k/2\)</span>. proof: I brute-forced k=6. It seems like it should be true in general.</p>
<p>recall: “even cycles even faster”: we can find even cycles (even is redundant because G’ is bipartite but whatever) in G’ in <span class="math inline">\(n^2\)</span> time.</p>
</div>
<div class="rmk envbox">
<p><strong>Remark.</strong> this is strictly worse in every way (except maybe simplicity) than the <span class="math inline">\(1.5\)</span>-approx in <span class="math inline">\(n^{2}\)</span> time proved above.</p>
</div>
<h3 id="on2-additive-25-approximation-assuming-g100"><span class="math inline">\(o(n^2)\)</span> additive <span class="math inline">\(+25\)</span> approximation assuming <span class="math inline">\(g&lt;100\)</span></h3>
<div class="thm envbox">
<p><strong>Theorem.</strong> There is an algorithm that, on graphs of girth <span class="math inline">\(g\le 100\)</span> outputs a cycle of length at most <span class="math inline">\(g+25\)</span> in time <span class="math inline">\(O(n^{1.999})\)</span></p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong></p>
<p>If <span class="math display">\[m \ge \Omega( n^{1+ \frac{1}{\left\lfloor (g+25)/2 \right\rfloor} }) \]</span> then we have super-saturation of <span class="math inline">\(2\left\lfloor (g+25)/2 \right\rfloor\)</span>-cycles. So wlog may assume this is not the case. Now, high-deg low-deg cases.</p>
<ul>
<li>High deg cost: <span class="math inline">\(n\cdot m/H\)</span>.</li>
<li>Low deg cost: <span class="math inline">\(n\cdot H^{\left\lceil g/2 \right\rceil}\)</span>.</li>
</ul>
<p>Balancing: <span class="math display">\[H = m^{\frac{1}{\left\lceil g/2 \right\rceil+1}}.\]</span></p>
<p>So the cost is <span class="math display">\[n m^{ \frac{\left\lceil g/2 \right\rceil}{\left\lceil g/2 \right\rceil+1} } \le n n^{\frac{\left\lceil g/2 \right\rceil}{\left\lceil g/2 \right\rceil+1}  \cdot (1+\frac{1}{\left\lfloor (g+25)/2 \right\rfloor})}.\]</span></p>
<p>not clear how good this is.</p>
</div>
<h3 id="additive-1-approximation-for-girth-in-n2-time">additive <span class="math inline">\(1\)</span>-approximation for girth in <span class="math inline">\(n^2\)</span> time</h3>
<div class="thm envbox">
<p><strong>Theorem.</strong> Given a graph <span class="math inline">\(G\)</span> of girth <span class="math inline">\(g\)</span> we will find a cycle of length at most <span class="math inline">\(g+1\)</span> in time <span class="math inline">\(O(n^{2})\)</span>. Futhermore, if <span class="math inline">\(g\)</span> is even the cycle we find will actually be of length <span class="math inline">\(g\)</span>.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> Algorithm: BFS-Cycle out of every vertex. Run time: <span class="math inline">\(O(n^{2})\)</span>.</p>
</div>
<h3 id="exact-algorithm-for-girth-in-nomega-time">Exact Algorithm for Girth in <span class="math inline">\(n^{\omega}\)</span> time</h3>
<div class="thm envbox">
<p><strong>Theorem.</strong> Exact Algorithm for Girth in <span class="math inline">\(n^{\omega}\)</span> time.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> First run the additive <span class="math inline">\(1\)</span>-approximation.</p>
<p>If it outputs a cycle of odd length we know it is equal to the girth. Else, call the length of the ouput cycle <span class="math inline">\(2\ell\)</span>. The girth is either <span class="math inline">\(2\ell\)</span> or <span class="math inline">\(2\ell-1\)</span>.</p>
<p>So, now we would just like to determine whether <span class="math inline">\(G\)</span> has a cycle of length <span class="math inline">\(2\ell-1\)</span>. At the beginning of this blog post we showed how to solve this with <span class="math inline">\(2\ell-2\)</span> matrix multiplications. But that’s not going to cut it here, we don’t really have a bound on <span class="math inline">\(\ell\)</span>.</p>
<p>Here’s how we construct a triangle-detection instance: Make a new graph <span class="math inline">\(G&#39;\)</span>. Place <span class="math inline">\(G\)</span> in <span class="math inline">\(G&#39;\)</span>. Then create copies of the vertices. Connect <span class="math inline">\(v\in V(G)\)</span> and copy the copy <span class="math inline">\(w&#39;\)</span> of <span class="math inline">\(w\in V(G)\)</span> if <span class="math inline">\(dist(v, w)=\ell-1\)</span>. We know this distance because of our BFS-ing.</p>
<p><span class="math inline">\(G&#39;\)</span> has a triangle iff <span class="math inline">\(G\)</span> has an <span class="math inline">\((2\ell-1)\)</span>-cycle. <img src="src/images/ink_img002.png" alt="ink_img002" /></p>
</div>
<h2 id="section">——–</h2>
<h2 id="virginia-lecture-11-stuff">virginia lecture 11 stuff</h2>
<div class="thm envbox">
<p><strong>Theorem.</strong> <span class="math inline">\(\widetilde{O}(n^{3}/m)\)</span> time <span class="math inline">\(+3\)</span> additive girth approx.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong></p>
<ul>
<li>case 1: graph has <span class="math inline">\(O(n\log n)\)</span> edges: just give up and do a quadratic time algorithm.</li>
<li>case 2: graph has enough edges that we can find a good enough cycle via super-saturation: then just do that</li>
<li>case 3: graph is reasonably sparse, but not crazy sparse.
<ul>
<li>case 3.1: assume that all vertices on the cycle have degree at most <span class="math inline">\(n^{1/k}\)</span>.
<ul>
<li>BFS-cycle for <span class="math inline">\(k-1\)</span> levels, only visiting low degree vertices.</li>
</ul></li>
<li>case 3.2: there is a high degree vertex on the cycle. sample <span class="math inline">\(n/H\)</span> vertices. <em>this won’t necessarily hit a high degree vertex, but should at least hit a neighbor of a high degree vertex</em>. So we could do a <span class="math inline">\(+3\)</span> approx this way. Very few vertices we need to BFS out of here.</li>
</ul></li>
</ul>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong></p>
<ul>
<li>“Finding and Counting Given Length Cycles” Alon Yuster Zwick:</li>
<li><span class="math inline">\(m^{4/3}\)</span> algorithm for <span class="math inline">\(C_4\)</span>’s</li>
<li><span class="math inline">\(m^{13/8}\)</span> algorithm for <span class="math inline">\(C_6\)</span>’s</li>
<li>Count number of <span class="math inline">\(C_k\)</span>’s for <span class="math inline">\(k\le 7\)</span> in <span class="math inline">\(n^{\omega}\)</span> time. Unlikely to be possible for <span class="math inline">\(C_8\)</span>’s because <span class="math inline">\(K_4\)</span>’s are harder than <span class="math inline">\(K_3\)</span>’s.</li>
</ul>
</div>
<h2 id="some-questions">some questions</h2>
<ul>
<li>subquadratic additive girth approx?</li>
</ul>
<h2 id="list-of-things-to-look-up">list of things to look up</h2>
<p>relevant graph parameters that we could do case-work on: - degeneracy - capped walls? - arboricity</p>
