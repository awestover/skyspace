<p>The topic today is taken from <a href="https://people.csail.mit.edu/virgi/6.890/">Virginia Williams’ MM + Graph Algs lecture notes</a>. Throughout the post <span class="math inline">\(\omega&lt;2.4\)</span> is the matrix multiplication exponent. MM will stand for matrix multiplication.</p>
<h1 id="cycles-versus-triangles">Cycles versus triangles</h1>
<div class="thm envbox">
<p><strong>Theorem.</strong> Let <span class="math inline">\(k\in \mathbb{N}_{\ge 3}\)</span> be a constant. directed/undirected-<span class="math inline">\(k\)</span>-cycle detection can be accomplished in <span class="math inline">\(n^{\omega}\)</span> time on <span class="math inline">\(n\)</span>-vertex graphs.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> It suffices to prove the theorem for directed graphs. We won’t need to explicitely mention this throughout the proof, but just note that the adjacency matrices needn’t be symmetric.</p>
<p>For <span class="math inline">\(k=3\)</span> you can just cube the adjacency matrix and check whether its trace is <span class="math inline">\(0\)</span>. This doesn’t work for <span class="math inline">\(k&gt;3\)</span> because powers of the adjacency matrix count walks, i.e., are allowed to repeat vertices.</p>
<p>Instead we do color coding! Color with <span class="math inline">\(k\)</span> colors. Make matrices <span class="math inline">\(A_1,A_2,\ldots, A_{k-1}\)</span> where <span class="math inline">\(A_i\)</span> represents the transition from color <span class="math inline">\(i\)</span> vertices to color <span class="math inline">\(i+1\)</span> vertices. That is, fix some ordering of the vertices within each color class, and then make the rows of <span class="math inline">\(A_i\)</span> be the vertices of color <span class="math inline">\(i\)</span> and the columns of <span class="math inline">\(A_i\)</span> be the vertices of color <span class="math inline">\(i+1\)</span>, and place edges if the vertices are adjacent.</p>
<p>Let <span class="math inline">\(B = A_1\cdot A_2\cdots A_{k-1}\)</span>; <span class="math inline">\(B\)</span> can be computed in <span class="math inline">\(n^{\omega}\)</span> time. <span class="math inline">\(B[u,v]\)</span> counts the number of <span class="math inline">\(k\)</span>-vertex paths from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span> whose vertices are colors <span class="math inline">\(1,2,\ldots, k\)</span>.</p>
<p>Now, for each <span class="math inline">\(u,v\)</span> check whether <span class="math inline">\(A[v,u]=1 \land B[u,v]&gt;0\)</span>. If the check ever passes then we have found a <span class="math inline">\(k\)</span>-cycle.</p>
<p>If the cycle was correctly colored we must find a <span class="math inline">\(k\)</span>-cycle in this manner.</p>
<p>The coloring succeeds with probability <span class="math inline">\(\frac{1}{k^{k}}\ge \Omega(1)\)</span>. Taking <span class="math inline">\(\Omega(\log n)\)</span> tries for the coloring lets us succeed at least once with high probability.</p>
<figure>
<img src="src/images/graph1.png" alt="" /><figcaption>src/images/graph1.png</figcaption>
</figure>
</div>
<blockquote>
<p>Is this tight? Turns out it is for odd cycles but not for even.</p>
</blockquote>
<div class="thm envbox">
<p><strong>Theorem.</strong> “Even cycles Even Faster”</p>
<ol type="1">
<li>For all <span class="math inline">\(k\)</span>, there is an <span class="math inline">\(n^{2}\)</span> algorithm to detect existence of a <span class="math inline">\(2k\)</span> cycle (and find it, if it exists).</li>
<li>There is an <span class="math inline">\(n^{2}\)</span> time algorithm to find the shortest even cycle.</li>
</ol>
</div>
<p>First I present two simple proofs of the theorem for <span class="math inline">\(k=2\)</span>. Then I present a proof (hopefully correct) that you can do <span class="math inline">\(n^{2+\frac{1}{k+1}}\)</span>. One day I’ll hopefully read their paper and know the proof for general <span class="math inline">\(k\)</span>.</p>
<div class="pf envbox">
<p><strong>Proof.</strong> 1. Common neighbor(x,y): make an <span class="math inline">\(n \times n\)</span> matrix <span class="math inline">\(A\)</span>. <span class="math inline">\(A[i,j]\)</span> will store whether we have found a common neighbor for <span class="math inline">\(i,j\)</span> so far. If any cell in the matrix ever gets hit twice then we found a <span class="math inline">\(4\)</span>-cycle.</p>
<p>What we do is, for each vertex <span class="math inline">\(v\)</span>, for each pair of vertices in <span class="math inline">\(N(v)\)</span> mark them as having a common neighbor.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> 2. wlog its bipartite: In particular, take <span class="math inline">\(G=(V,E)\)</span>, and form <span class="math inline">\(G&#39;\)</span> by duplicating the vertex set to <span class="math inline">\(V\sqcup V&#39;\)</span> and put an edge between <span class="math inline">\(uv&#39;\)</span> if <span class="math inline">\(uv\)</span> is an edge in <span class="math inline">\(G\)</span>. Then, if you had a <span class="math inline">\(4\)</span>-cycle in <span class="math inline">\(G\)</span> it is converted into a <span class="math inline">\(4\)</span>-cycle in <span class="math inline">\(G&#39;\)</span>. But of course <span class="math inline">\(G&#39;\)</span> is bipartite and only a constant-factor larger. Then, run BFS-cycle out of each vertex (for depth <span class="math inline">\(2\)</span>). This must terminate fast. More precisely, for all vertices in the neighbor-set of one of your vertices color their left-neighbors. If a left-neighbor gets colored twice it means you have a <span class="math inline">\(C_4\)</span>.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> goal: check whether our graph contains a <span class="math inline">\(2k\)</span>-cycle Note: wlog <span class="math inline">\(m\le o(n^{1+\frac{1}{k}})\)</span> or else we are guaranteed to have a <span class="math inline">\(2k\)</span>-cycle</p>
<p><strong>Case 1:</strong> There exists a high degree vertex, say with degree larger than <span class="math inline">\(H\)</span> somewhere on the cycle. There aren’t so many vertices like this. It costs <span class="math inline">\(\frac{m}{H} m\)</span> to just BFS out of all the high degree vertices.</p>
<p><strong>Case 2</strong>: Negation of case 1. i.e., all vertices on the cycle have degree smaller than <span class="math inline">\(H\)</span>. Then we can do BFS a bit more efficiently, in time <span class="math inline">\(n H^{k}\)</span>.</p>
<p>Balancing (1) and (2) gives:</p>
<p><span class="math display">\[ \frac{m}{H}m = nH^{k} \implies \frac{m^{2}}{n} = H^{k+1}.\]</span> Hence <span class="math inline">\(H=(\frac{m^{2}}{n})^{\frac{1}{k+1}}\)</span> is the right choice.</p>
<p>This yields running time <span class="math inline">\(n^{2+\frac{1}{k+1}}\)</span>. Humm, not quite <span class="math inline">\(n^{2}.\)</span> On reflection maybe this is why their paper is 14 pages not 1 page.</p>
</div>
<p>Now I establish that odd cycle detection does require <span class="math inline">\(n^{\omega}\)</span> time. First we prove another interesting result:</p>
<div class="thm envbox">
<p><strong>Theorem.</strong> Let <span class="math inline">\(k\)</span> be an odd constant. Then directed-<span class="math inline">\(k\)</span>-cycle is equivalently hard to undirected-<span class="math inline">\(k\)</span>-cycle.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> We can convert an instance of undirected-<span class="math inline">\(k\)</span>-cycle to directed-<span class="math inline">\(k\)</span>-cycle by thinking of each edge <span class="math inline">\(\left\{ u,v\right\}\)</span> as being two directed edges <span class="math inline">\(u\to v\)</span> and <span class="math inline">\(v\to u\)</span>.</p>
<p>The other direction is more subtle. We are given an instance of directed-<span class="math inline">\(k\)</span>-cycle. By color coding we assume that the graph has parts <span class="math inline">\(V_1,V_2,\ldots, V_k\)</span> and we only consider edges from <span class="math inline">\(V_i\to V_{i+1}\)</span>. Let this new graph be <span class="math inline">\(G&#39;\)</span>.</p>
<p>Let <span class="math inline">\(G&#39;&#39;\)</span> be the graph obtained by dropping the directionality on the edges in <span class="math inline">\(G&#39;\)</span>.</p>
<p><strong>Claim</strong>: <span class="math inline">\(G&#39;&#39;\)</span> has an undirected-<span class="math inline">\(k\)</span>-cycle iff colorful <span class="math inline">\(G&#39;\)</span> has a directed <span class="math inline">\(k\)</span>-cycle.</p>
<p>Proof of claim: If <span class="math inline">\(G&#39;\)</span> has a cycle then dropping the directionality won’t kill the cycle. If the cycle in <span class="math inline">\(G&#39;&#39;\)</span> uses a vertex from each of the <span class="math inline">\(k\)</span> parts <span class="math inline">\(V_i\)</span> then it is clearly a cycle in <span class="math inline">\(G&#39;\)</span>. Assume for contradiction that there is a cycle in <span class="math inline">\(G&#39;&#39;\)</span> that doesn’t use some part <span class="math inline">\(V_i\)</span>. But <span class="math inline">\(G&#39;&#39;\setminus V_i\)</span> is bipartite, so it cannot contain an odd cycle.</p>
<figure>
<img src="src/images/graph2.png" alt="" /><figcaption>Depictionn of the layered grahp</figcaption>
</figure>
<figure>
<img src="src/images/graph3.png" alt="" /><figcaption>Why this breaks if k is even</figcaption>
</figure>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> Let <span class="math inline">\(k\)</span> be a constant. Directed-<span class="math inline">\(k\)</span>-cycle is equivalently hard to triangle detection.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> We already showed how to solve directed-<span class="math inline">\(k\)</span>-cycle with MM.</p>
<p>Let <span class="math inline">\(G = (V, E)\)</span> be a graph we want to do triangle detection in. Make <span class="math inline">\(k\)</span> copies of the vertex set: <span class="math inline">\(V_1,V_2,\ldots, V_k\)</span>. We denote the copies of a vertex <span class="math inline">\(v\)</span> by <span class="math inline">\(v_1,v_2,\ldots, v_k\)</span>.</p>
<ul>
<li><p>Connect <span class="math inline">\(u_1\to v_2 \in V_1 \times V_2\)</span> iff <span class="math inline">\((u,v)\in E(G)\)</span>.</p></li>
<li><p>Connnect <span class="math inline">\(u_k\to v_1 \in V_{k}\times V_1\)</span> iff <span class="math inline">\((u,v) \in E(G)\)</span></p></li>
<li><p>For each <span class="math inline">\(i\in [2, k-1]\)</span> and each vertex <span class="math inline">\(v\in V\)</span> connect <span class="math inline">\(v_i\to v_{i+1}\in V_i \times V_{i+1}\)</span>.</p>
<p>A <span class="math inline">\(k\)</span>-cycle in this new graph corresponds to a triangle in the original graph.</p></li>
</ul>
</div>
<h1 id="girth">Girth</h1>
<p><strong>GIRTH</strong>: length of shortest cycle</p>
<h3 id="approx-in-n1.5-time"><span class="math inline">\(2\)</span>-approx in <span class="math inline">\(n^{1.5}\)</span> time</h3>
<div class="rmk envbox">
<p><strong>Remark.</strong> In “New Subquadratic Approximation Algorithms for the Girth” Knudsen talks about Virginia and Roditty’s paper. He observes that her algorithm outputs a cycle of size <span class="math inline">\(2\left\lceil g/2 \right\rceil + 2\left\lceil g/4 \right\rceil\)</span> when the girth is <span class="math inline">\(g\)</span>. So technically for <span class="math inline">\(g=3\)</span> this is a <span class="math inline">\(2\)</span>-approx. But for larger values of <span class="math inline">\(g\)</span> it is essentially a <span class="math inline">\(1.5\)</span>-approx. And her algo is indeed <span class="math inline">\(n^{5/3}\)</span>.</p>
<p>Note: Knudsen gives a sub-quadratic algorithm that, if the girth is <span class="math inline">\(g\)</span>, returns a cycle with size at most <span class="math display">\[2\left\lceil g/2 \right\rceil+2\left\lceil \frac{g}{2(k-1)} \right\rceil\le (1+\varepsilon)g + 3,\]</span> for suitably large <span class="math inline">\(k\)</span>, although the run time is of course <span class="math inline">\(n^{2-1/k}\)</span>.</p>
<p>So I feel like the barrier to an <span class="math inline">\(o(n^{2})\)</span> <span class="math inline">\((2-\varepsilon)\)</span>-approx is really “given a graph with girth <span class="math inline">\(3\)</span>, can you find any of a triangle, a square, or a pentagon in subquadratic time?”</p>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> There is an algorithm that, given an <span class="math inline">\(n\)</span>-vertex graph <span class="math inline">\(G\)</span> with girth <span class="math inline">\(g\ge 3\)</span> outputs a cycle of length at most <span class="math display">\[2\left\lceil g/2 \right\rceil+2\left\lceil g/4 \right\rceil\le 2g,\]</span> in running time <span class="math inline">\(n^{5/3}\)</span>.</p>
</div>
<div class="rmk envbox">
<p><strong>Remark.</strong> If you want to turn the decision problem stated above into actually an algorithm for finding the shortest cycle, then you can do the standard binary search trick.</p>
</div>
<hr />
<div class="pf envbox">
<p><strong>Proof.</strong> <strong>CAUTION</strong> I have not been especially careful with the floors and ceilings in this proof. They are really important if you care about small <span class="math inline">\(g\)</span>! Beware.</p>
<p>Let <span class="math inline">\(C\)</span> be a length <span class="math inline">\(g\)</span> cycle in <span class="math inline">\(G\)</span>. Call a ball <strong>huge</strong> if it has size larger than <span class="math inline">\(n^{1/3}\)</span>.</p>
<p><strong>Case 1:</strong> Some vertex <span class="math inline">\(v\in C\)</span> has a huge <span class="math inline">\(t\)</span>-radius ball, for some <span class="math inline">\(t\le \left\lceil g/4 \right\rceil\)</span>. Then, if we randomly sample a subset <span class="math inline">\(S\)</span> of size <span class="math inline">\(n^{2/3}\log n\)</span> we intersect with <span class="math inline">\(B\)</span> with high probability. Imagine we ran BFS-cycle out of <span class="math inline">\(y\in B\)</span>. Then we would find a cycle of length at most <span class="math inline">\(g+2t \le 2g\)</span>. So what we do is run BFS-cycle out of all the points in <span class="math inline">\(S\)</span>. The cost of this is <span class="math inline">\(n^{2/3} \cdot n\le n^{5/3}\)</span>.</p>
<p><strong>Case 2:</strong> No vertices on the cycle have huge <span class="math inline">\(\left\lceil g/4 \right\rceil\)</span>-radius balls. Sort the vertices in the graph as <span class="math inline">\(v_1,v_2,\ldots, v_n\)</span> based on how fast their ball gets huge, i.e., the smallest <span class="math inline">\(k\)</span> such that their radius-<span class="math inline">\(k\)</span> ball is huge. In particular, make it so that <span class="math inline">\(v_1\)</span>’s ball becomes huge the slowest and <span class="math inline">\(v_n\)</span>’s ball becomes huge the fastest. Let <span class="math inline">\(H_k\)</span> denote the induced subgraph on <span class="math inline">\(v_1,v_2,\ldots, v_k\)</span>.</p>
<p>We do a BFS-Cycle from vertex <span class="math inline">\(k\)</span> in <span class="math inline">\(H_k\)</span> for each <span class="math inline">\(k\)</span>, except we stop once we have visited <span class="math inline">\(n^{2/3}\)</span> vertices. Let <span class="math inline">\(k_0\)</span> be the first index when all vertices of <span class="math inline">\(C\)</span> are contained in <span class="math inline">\(H_{k_0}\)</span>. We claim that doing this limited BFS in <span class="math inline">\(H_{k_0}\)</span> will find a cycle of length at most <span class="math inline">\(2g\)</span>.</p>
<p>Note that all vertices <span class="math inline">\(v\in H_{k_0}\)</span> satisfy <span class="math inline">\(|B(v, \left\lceil g/4 \right\rceil)| \le n^{1/3}\)</span> and thus <span class="math inline">\(|B(v, 2\left\lceil g/4 \right\rceil)|\le n^{2/3}\)</span>. Thus the BFS-cycle out of <span class="math inline">\(k_0\)</span> will successfully find a cycle of length like at most <span class="math inline">\(4\left\lceil g/4 \right\rceil+1\)</span> ish.</p>
<p>The run time of doing this is going to be <span class="math inline">\(n\cdot n^{2/3}\le n^{5/3}\)</span>.</p>
</div>
<hr />
<h3 id="a-worse-algorithm">A worse algorithm:</h3>
<div class="prop envbox">
<p><strong>Proposition.</strong> 2-approx in <span class="math inline">\(n^2\)</span> time.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> Let <span class="math inline">\(G=(V, E)\)</span>. form a new graph with vertex sets <span class="math inline">\(V, V&#39;\)</span>. make an edge <span class="math inline">\(xy&#39; \in G&#39;\)</span> for <span class="math inline">\(x\in V, y&#39;\in V&#39; \iff xy\in E(G)\)</span>. So <span class="math inline">\(G&#39;\)</span> is bipartite. claim: If G’ has a cycle of length <span class="math inline">\(k\)</span> then G has a cycle of length at least <span class="math inline">\(k/2\)</span>. proof: I brute-forced k=6. It seems like it should be true in general.</p>
<p>recall: “even cycles even faster”: we can find even cycles (even is redundant because G’ is bipartite but whatever) in G’ in <span class="math inline">\(n^2\)</span> time.</p>
</div>
<div class="rmk envbox">
<p><strong>Remark.</strong> this is strictly worse in every way (except maybe simplicity) than the <span class="math inline">\(1.5\)</span>-approx in <span class="math inline">\(n^{2}\)</span> time proved above.</p>
</div>
<h3 id="approx-in-n2-19-time"><span class="math inline">\(4\)</span>-approx in <span class="math inline">\(n^{2-1/9}\)</span> time</h3>
<p><strong>TODO</strong>: understand my high-degree low-degree construction better. in particular, does it give an additive or multiplicative approximation? presumably multiplicative?</p>
<div class="thm envbox">
<p><strong>Theorem.</strong> <span class="math inline">\(4\)</span>-approx in <span class="math inline">\(n^{2-1/9}\)</span> time</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> PoC: if <span class="math inline">\(G\)</span> contains a triangle we want to output a cycle of length at most <span class="math inline">\(12\)</span>. Else, we provide no guarantees.</p>
<p>I’ll just do the PoC. But I’m pretty sure stuff should work out strictly better if the min cycle we are worrying about is larger.</p>
<p>If <span class="math inline">\(m\ge n^{\frac{7}{6}}\)</span> then it’s probably really easy to find a <span class="math inline">\(12\)</span>-cycle. So lets assume this is not the case, i.e., <span class="math inline">\(m\le n^{\frac{7}{6}}\)</span>. Now, we do the high-degree low-degree business. That is, let <span class="math inline">\(H\)</span> be the high-degree threshold. There are at most <span class="math inline">\(\frac{m}{H}\)</span> high-degree vertices, so BFS-ing over all of these costs at most <span class="math inline">\(\frac{m^{2}}{H}\)</span>. For low-degree vertices we do fancy BFS where we ignore high-degree vertices. This costs <span class="math inline">\(nH^{2}\)</span> (two levels of BFS for fiding triangles.) Balancing this gives: <span class="math display">\[\frac{m}{H}m = nH^{2}  \implies H = (m^{2} / n)^{\frac{1}{3}}
 = n^{\frac{4}{9}}.\]</span></p>
<p>Then the cost is <span class="math inline">\(nH^{2} = n^{2-\frac{1}{9}}.\)</span></p>
</div>
<h3 id="additive-1-approximation-for-girth-in-n2-time">additive <span class="math inline">\(1\)</span>-approximation for girth in <span class="math inline">\(n^2\)</span> time</h3>
<div class="thm envbox">
<p><strong>Theorem.</strong> Given a graph <span class="math inline">\(G\)</span> of girth <span class="math inline">\(g\)</span> we will find a cycle of length at most <span class="math inline">\(g+1\)</span> in time <span class="math inline">\(O(n^{2})\)</span>. Futhermore, if <span class="math inline">\(g\)</span> is even the cycle we find will actually be of length <span class="math inline">\(g\)</span>.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> Algorithm: BFS-Cycle out of every vertex. Run time: <span class="math inline">\(O(n^{2})\)</span>.</p>
</div>
<h3 id="exact-algorithm-for-girth-in-nomega-time">Exact Algorithm for Girth in <span class="math inline">\(n^{\omega}\)</span> time</h3>
<div class="thm envbox">
<p><strong>Theorem.</strong> Exact Algorithm for Girth in <span class="math inline">\(n^{\omega}\)</span> time.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> First run the additive <span class="math inline">\(1\)</span>-approximation.</p>
<p>If it outputs a cycle of odd length we know it is equal to the girth. Else, call the length of the ouput cycle <span class="math inline">\(2\ell\)</span>. The girth is either <span class="math inline">\(2\ell\)</span> or <span class="math inline">\(2\ell-1\)</span>.</p>
<p>So, now we would just like to determine whether <span class="math inline">\(G\)</span> has a cycle of length <span class="math inline">\(2\ell-1\)</span>. At the beginning of this blog post we showed how to solve this with <span class="math inline">\(2\ell-2\)</span> matrix multiplications. But that’s not going to cut it here, we don’t really have a bound on <span class="math inline">\(\ell\)</span>.</p>
<p>Here’s how we construct a triangle-detection instance: Make a new graph <span class="math inline">\(G&#39;\)</span>. Place <span class="math inline">\(G\)</span> in <span class="math inline">\(G&#39;\)</span>. Then create copies of the vertices. Connect <span class="math inline">\(v\in V(G)\)</span> and copy the copy <span class="math inline">\(w&#39;\)</span> of <span class="math inline">\(w\in V(G)\)</span> if <span class="math inline">\(dist(v, w)=\ell-1\)</span>. We know this distance because of our BFS-ing.</p>
<p><span class="math inline">\(G&#39;\)</span> has a triangle iff <span class="math inline">\(G\)</span> has an <span class="math inline">\((2\ell-1)\)</span>-cycle. <img src="src/images/ink_img002.png" alt="ink_img002" /></p>
</div>
