\newcommand{\one}{\mathbbm{1}}
\newcommand{\bigO}{\mathcal{O}}
\DeclareMathOperator{\E}{\mathbb{E}}
\DeclareMathOperator{\Var}{\text{Var}}
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\Id}{Id}
\DeclareMathOperator{\img}{Img}
\DeclareMathOperator{\polylog}{\text{polylog}}
\DeclareMathOperator{\poly}{\text{poly}}
\newcommand{\st}{\text{ such that }}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\interior}[1]{ {\kern0pt#1}^{\mathrm{o}} }
\newcommand{\mb}{\mathbf}
\newcommand{\partition}{\vdash}
\newcommand{\x}{\mathbf{x}}
\newcommand{\y}{\mathbf{y}}
\newcommand{\z}{\mathbf{z}}
\newcommand{\eps}{\varepsilon}
\renewcommand{\d}{\mathrm{d}}
\renewcommand{\Re}{\mathrm{Re}}
\renewcommand{\Im}{\mathrm{Im}}

\newcommand{\setof}[2]{\left\{ #1\; : \;#2 \right\}}
\newcommand{\set}[1]{\left\{ #1\right\}}

\newcommand{\R}{\mathbb{R}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\contr}{\[ \Rightarrow\!\Leftarrow \]}
\newcommand{\defeq}{\vcentcolon=}
\newcommand{\eqdef}{=\vcentcolon}

\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\paren}[1]{\left( #1 \right)}
\newcommand{\ang}[1]{\langle #1 \rangle}
\newcommand{\abs}[1]{\left| #1 \right|}


Problems (from "Parameterized Algorithms" textbook): 

> Does a graph $G$ contain $k$ vertex-disjoint triangles?

> Does a graph $G$ contain a subgraph isomorphic to a $k$-vertex
tree $T$?

In fact, these are both special cases of a more general result: 
there is (I'm pretty sure) a $2^{O(k)}n^{O(1)}$ algorithm for
detecting whether any pattern graph of bounded treewidth occurs
as a subgraph of your graph. Maybe I'll try to think about how to
do that in a moment.


<div class="thm envbox">**Theorem.**
$2^{O(k)}n^{O(1)}$ algorithm for triangle packing.
</div>
<div class="pf envbox">**Proof.**
Color code with $3k$ colors. Hope that each of the $3k$ vertices
we need for our triangles got a distinct color, this happens with
probability at least $2^{-O(k)}$.

Now we do dynamic programming.
For any subset $C\subseteq [3k]$ of size a multiple of $3$ define
Let $S[C]$ to be the boolean indicating whether there are $|C|/3$
vertex disjoint triangles that can be made by using each color
from  $C$ exactly once.

Then we can recursively compute $S[C]$ as follows:
```python
for c1,c2,c3 in C:
  if there is a c1,c2,c3 triangle and S[C - c1c2c3]:
    YES
  else:
    NO
```
</div>

still can't figure out trees actually. rip.

