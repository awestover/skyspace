{title}
FPT part 6
{contents}

{description}
tree width part 2
{body}

# 7.4 monadic logic on graphs

They define a certain logic on graphs. 
Let's just write some examples.

beg ex

**partition**: given three vertex subsets, are they a partition
of the vertices of the graph?

$$\text{partition}(X_1,X_2,X_3) = \forall_{v\in V} v\in X_1 \lor v\in X_2 \lor v\in X_3.$$

**indep**: given a vertex subset, is it an independent set?

$$\text{indep}(X) = \forall_{u,v \in X} uv\notin E.$$


**3COLOR**: is my graph three colorable?

$$\exists_{X_1,X_2,X_3 \subseteq V} \text{partition}(X_1,X_2,X_3) \land \text{indep}(X_1) \land \text{indep}(X_2) \land \text{indep}(X_3).$$

end ex

beg thm
Courcelle's theorem:

Let $G$ be a graph with tree width $t$, and let $\varphi$ be a
formula in monadic second-order logic. Then, there is an
algorithm that determines whether $\varphi$ is satisfied on  $G$
in runnning time $f(||\varphi||, t)\cdot n$ for a computable
function  $f$.
end thm

beg rmk
We can't give good bounds on $f$: if you alternate quantifiers a
lot it can be really really really massive. Like much worse than tower.
So this is more of a "if your problem is like this then its FPT"
than the final word on parameterization by tree-width.
end rmk

The following optimization version of Courcelle's theorem is also
useful, e.g., for vertex cover, where it's not clear how to get a
monadic formula thing that doesn't have a $k$ dependence.

beg thm
If you have a formula and a pretty nice function you want to
optimize, that's FPT in $||\varphi||$ and tree-width too.
end thm

# other interpretations of tree-width

## path-width

beg thm
The following graph parameters are basically (up to a dumb $\pm 1$) equivalent:

- node-search number
- interval width
- path width

end thm

Here is a hypothetical story (not real life) to explain
node-search number.

Blobby is on the run from the cops. Luckily Blobby is omniscient
and has unbounded speed.
He's also invisible!
Unforunately for him, the cops are
really out to get him. They know his weakness: each of the cops
has a box of pizza. If Blobby ever occupies the same vertex as a
cop he will be sucked into the box of pizza.
The cops start wherever and at each step you can do a **place**
move: take a cop from the pool of unplaced cops and place it, 
or you can do a **extract** move: take a cop from the graph and
put them into the unused cops pool.

The node-search number of a graph is the fewest number of cops
needed to catch Blobby.

Here's a picture that I think helps see why node-search number is
related to interval width / path width:

![ink_img011](images/ink_img011.png)

It might be hard to think of Blobby as being omniscient,
unbounded speed and invisible. Instead, you can think of Blobby
as being a gas that the cops are cleaning up. If there is gas on
an edge it will spread to any edges that share a vertex with it,
unless that vertex is blocked by a cop. If cops occupy both
endpoints of an edge then the gas dies in that edge. But of
course edges can be recontaminated.

## tree-width

Somewhat similar story for tree-width.

Key difference: cops can see the Blobby in the tree chase
version. And cops have to announce their next move, and Blobby
gets to choose where to go after the cops announce move. 

**bramble**: a collection of pairwise touching connected vertex subsets. 
(We say that two vertex subsets are *touching* if they share a
vertex or if there is an edge between them).

beg thm
treewidth $k$ iff bramble of order $k+1$.
end thm
beg pf
one direction pretty clear, other apparently very tricky.
end pf

beg def
cordal graph:
Largest induced cycle is a triangle.

cordal width: min max-clique in a chordal super graph.

end def

beg thm

TFAE up to $\pm 1$

- treewidth
- chordal width
- max bramble
- cops to catch visible robber

end thm

# computing treewidth

unforunately tree-width exactly NP-hard. But we can settle for
FPT algo / approx algo.

beg def
$H$ is a minor of $G$ if you can obtain $H$ from $G$ by some
combination of deleting vertices, edges, and contracting edges.
end def

beg rmk
Apparently you can efficiently test if a constant size graph is a
minor of your graph. In like $n^{3}$ time. No idea how.
end rmk

beg thm 
MEME FPT algorithm for computing treewidth (i.e., determining
whether treewidth is larger than $k$ or not).
end thm
beg pf

tree-width is **minor monotone**: taking minors only decreases
tree-width. Hence, the set of graphs with tree-width at most $k$
is closed under taking minors. Hence, there is a set of forbidden
minors, whose size depends only on $k$, such that a graph has
tree-width at most $k$ iff it avoids the forbidden minors.

Thus, to check if a graph has tree-width at most $k$ you just
check for each of the forbidden minors whether it is a minor of
your graph.

This is not such a useful algorithm maybe because determining the
set of forbidden minors seems really hard, and that set is going
to be freaking massive.

end pf

beg rmk
Ok there is also an actual (uniform) algorithm. with run time
$k^{k^{3}} \cdot n$. 

But this is a bit slow, so we're gonna just do an approx algo
instead.
end rmk

beg thm
There is a $8^{k}k^{2}n^2$ algo that either constructs a tree
decomposition of widdth at most $4k+4$ or outputs (correctly)
that $G$ has treewidth larger than $k$.

Ok, more recently:
There is a $2^{O(k)}\cdot n$ algo that either constructs a tree
decomposition of widdth at most $5k+5$ or outputs (correctly)
that $G$ has treewidth larger than $k$.

Anyways, we're gonna prove the easier version. 
But it's looking pretty intense, so prolly has to wait till after
lunch.
end thm

Before proving giving an FPT treewidth/decomposition
approximation algorithm we need some graph theory lemmas.

beg rmk
In a tree there is a "centroid": a vertex whose removal splits
the tree into some subtrees each with at most $n/2$ vertices.

It turns out that graphs of bounded tree-width also have "small
separators": if a graph has tree-width $k$ there is a set of size
$k+1$ whose removal "splits the graph nicely".
We need a weighted version of this.
end rmk

beg lem
separation lemma
end lem


beg rmk
Not related to tree-width but I finally got around to fixing my
image compilation script to only compile images in the file that
I'm editting rather than all the images. I should probably still
upgrade it to auto compile rather than manual compile. 
But this is a big step up: before now I was really scared to add
images bc it took like 10sec to compile them. Now it's back down
to like 1sec. 
As I always like to say "blogging isn't like ski rental because
if someone breaks your legs you probably will end up writing more
blog posts not less."
end rmk

