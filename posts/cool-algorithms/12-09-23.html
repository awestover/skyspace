<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <title>skyspace</title>

    <link href="../../formatting/pandoc.css" rel="stylesheet">
    <link href="../../formatting/envbox.css" rel="stylesheet">
    <link href="../../formatting/bars.css" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.4.1/jquery.easing.min.js" integrity="sha256-H3cjtrm/ztDeuhCN9I4yh4iN2Ybx/y1RM7rMmAesA0k=" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>

  </head>
  <body>
    <div class="wrapper">
      <nav id="sidebar">
        <div id="sidebar-content">
          <div class="sidebar-header">
            <h5>skyspace</h5>
          </div>
          <ul class="list-unstyled components">
            <img style="width:100%; max-width:250px" src="../../images/cat.png" alt="cat"/>
            <li> <a href="../../index.html">Home</a> </li>
            <li> <a href="../../about.html">About</a> </li>
            <li> <a href="../../topics.html">Topics</a> </li>
            <hr>
            <div id="toc">
            <li> <a href="#cycles-versus-triangles
" class="js-scroll-trigger">Cycles-versus-triangles
</a> </li>
<li> <a href="#girth
" class="js-scroll-trigger">Girth
</a> </li>
            </div>
          </ul>
        </div>
      </nav>

      <div id="content"> 
      <p>The topic today is taken from <a href="https://people.csail.mit.edu/virgi/6.890/">Virginia Williams’ MM + Graph Algs lecture notes</a>. Throughout the post <span class="math inline">\(\omega&lt;2.4\)</span> is the matrix multiplication exponent. MM will stand for matrix multiplication.</p>
<h1 id="cycles-versus-triangles">Cycles versus triangles</h1>
<div class="thm envbox">
<p><strong>Theorem.</strong> Let <span class="math inline">\(k\in \mathbb{N}_{\ge 3}\)</span> be a constant. directed/undirected-<span class="math inline">\(k\)</span>-cycle detection can be accomplished in <span class="math inline">\(n^{\omega}\)</span> time on <span class="math inline">\(n\)</span>-vertex graphs.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> It suffices to prove the theorem for directed graphs. We won’t need to explicitely mention this throughout the proof, but just note that the adjacency matrices needn’t be symmetric.</p>
<p>For <span class="math inline">\(k=3\)</span> you can just cube the adjacency matrix and check whether its trace is <span class="math inline">\(0\)</span>. This doesn’t work for <span class="math inline">\(k&gt;3\)</span> because powers of the adjacency matrix count walks, i.e., are allowed to repeat vertices.</p>
<p>Instead we do color coding! Color with <span class="math inline">\(k\)</span> colors. Make matrices <span class="math inline">\(A_1,A_2,\ldots, A_{k-1}\)</span> where <span class="math inline">\(A_i\)</span> represents the transition from color <span class="math inline">\(i\)</span> vertices to color <span class="math inline">\(i+1\)</span> vertices. That is, fix some ordering of the vertices within each color class, and then make the rows of <span class="math inline">\(A_i\)</span> be the vertices of color <span class="math inline">\(i\)</span> and the columns of <span class="math inline">\(A_i\)</span> be the vertices of color <span class="math inline">\(i+1\)</span>, and place edges if the vertices are adjacent.</p>
<p>Let <span class="math inline">\(B = A_1\cdot A_2\cdots A_{k-1}\)</span>; <span class="math inline">\(B\)</span> can be computed in <span class="math inline">\(n^{\omega}\)</span> time. <span class="math inline">\(B[u,v]\)</span> counts the number of <span class="math inline">\(k\)</span>-vertex paths from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span> whose vertices are colors <span class="math inline">\(1,2,\ldots, k\)</span>.</p>
<p>Now, for each <span class="math inline">\(u,v\)</span> check whether <span class="math inline">\(A[v,u]=1 \land B[u,v]&gt;0\)</span>. If the check ever passes then we have found a <span class="math inline">\(k\)</span>-cycle.</p>
<p>If the cycle was correctly colored we must find a <span class="math inline">\(k\)</span>-cycle in this manner.</p>
<p>The coloring succeeds with probability <span class="math inline">\(\frac{1}{k^{k}}\ge \Omega(1)\)</span>. Taking <span class="math inline">\(\Omega(\log n)\)</span> tries for the coloring lets us succeed at least once with high probability.</p>
<figure>
<img src="src/images/graph1.png" alt="" /><figcaption>src/images/graph1.png</figcaption>
</figure>
</div>
<blockquote>
<p>Is this tight? Turns out it is for odd cycles but not for even.</p>
</blockquote>
<div class="thm envbox">
<p><strong>Theorem.</strong> “Even cycles Even Faster”</p>
<ol type="1">
<li>For all <span class="math inline">\(k\)</span>, there is an <span class="math inline">\(n^{2}\)</span> algorithm to detect existence of a <span class="math inline">\(2k\)</span> cycle (and find it, if it exists).</li>
<li>There is an <span class="math inline">\(n^{2}\)</span> time algorithm to find the shortest even cycle.</li>
</ol>
</div>
<p>First I present two simple proofs of the theorem for <span class="math inline">\(k=2\)</span>. Then I present a proof (hopefully correct) that you can do <span class="math inline">\(n^{2+\frac{1}{k+1}}\)</span>. One day I’ll hopefully read their paper and know the proof for general <span class="math inline">\(k\)</span>.</p>
<div class="pf envbox">
<p><strong>Proof.</strong> 1. Common neighbor(x,y): make an <span class="math inline">\(n \times n\)</span> matrix <span class="math inline">\(A\)</span>. <span class="math inline">\(A[i,j]\)</span> will store whether we have found a common neighbor for <span class="math inline">\(i,j\)</span> so far. If any cell in the matrix ever gets hit twice then we found a <span class="math inline">\(4\)</span>-cycle.</p>
<p>What we do is, for each vertex <span class="math inline">\(v\)</span>, for each pair of vertices in <span class="math inline">\(N(v)\)</span> mark them as having a common neighbor.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> 2. wlog its bipartite: In particular, take <span class="math inline">\(G=(V,E)\)</span>, and form <span class="math inline">\(G&#39;\)</span> by duplicating the vertex set to <span class="math inline">\(V\sqcup V&#39;\)</span> and put an edge between <span class="math inline">\(uv&#39;\)</span> if <span class="math inline">\(uv\)</span> is an edge in <span class="math inline">\(G\)</span>. Then, if you had a <span class="math inline">\(4\)</span>-cycle in <span class="math inline">\(G\)</span> it is converted into a <span class="math inline">\(4\)</span>-cycle in <span class="math inline">\(G&#39;\)</span>. But of course <span class="math inline">\(G&#39;\)</span> is bipartite and only a constant-factor larger. Then, run BFS-cycle out of each vertex (for depth <span class="math inline">\(2\)</span>). This must terminate fast. More precisely, for all vertices in the neighbor-set of one of your vertices color their left-neighbors. If a left-neighbor gets colored twice it means you have a <span class="math inline">\(C_4\)</span>.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> goal: check whether our graph contains a <span class="math inline">\(2k\)</span>-cycle Note: wlog <span class="math inline">\(m\le o(n^{1+\frac{1}{k}})\)</span> or else we are guaranteed to have a <span class="math inline">\(2k\)</span>-cycle</p>
<p><strong>Case 1:</strong> There exists a high degree vertex, say with degree larger than <span class="math inline">\(H\)</span> somewhere on the cycle. There aren’t so many vertices like this. It costs <span class="math inline">\(\frac{m}{H} m\)</span> to just BFS out of all the high degree vertices.</p>
<p><strong>Case 2</strong>: Negation of case 1. i.e., all vertices on the cycle have degree smaller than <span class="math inline">\(H\)</span>. Then we can do BFS a bit more efficiently, in time <span class="math inline">\(n H^{k}\)</span>.</p>
<p>Balancing (1) and (2) gives:</p>
<p><span class="math display">\[ \frac{m}{H}m = nH^{k} \implies \frac{m^{2}}{n} = H^{k+1}.\]</span> Hence <span class="math inline">\(H=(\frac{m^{2}}{n})^{\frac{1}{k+1}}\)</span> is the right choice.</p>
<p>This yields running time <span class="math inline">\(n^{2+\frac{1}{k+1}}\)</span>. Humm, not quite <span class="math inline">\(n^{2}.\)</span> On reflection maybe this is why their paper is 14 pages not 1 page.</p>
</div>
<p>Now I establish that odd cycle detection does require <span class="math inline">\(n^{\omega}\)</span> time. First we prove another interesting result:</p>
<div class="thm envbox">
<p><strong>Theorem.</strong> Let <span class="math inline">\(k\)</span> be an odd constant. Then directed-<span class="math inline">\(k\)</span>-cycle is equivalently hard to undirected-<span class="math inline">\(k\)</span>-cycle.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> We can convert an instance of undirected-<span class="math inline">\(k\)</span>-cycle to directed-<span class="math inline">\(k\)</span>-cycle by thinking of each edge <span class="math inline">\(\left\{ u,v\right\}\)</span> as being two directed edges <span class="math inline">\(u\to v\)</span> and <span class="math inline">\(v\to u\)</span>.</p>
<p>The other direction is more subtle. We are given an instance of directed-<span class="math inline">\(k\)</span>-cycle. By color coding we assume that the graph has parts <span class="math inline">\(V_1,V_2,\ldots, V_k\)</span> and we only consider edges from <span class="math inline">\(V_i\to V_{i+1}\)</span>. Let this new graph be <span class="math inline">\(G&#39;\)</span>.</p>
<p>Let <span class="math inline">\(G&#39;&#39;\)</span> be the graph obtained by dropping the directionality on the edges in <span class="math inline">\(G&#39;\)</span>.</p>
<p><strong>Claim</strong>: <span class="math inline">\(G&#39;&#39;\)</span> has an undirected-<span class="math inline">\(k\)</span>-cycle iff colorful <span class="math inline">\(G&#39;\)</span> has a directed <span class="math inline">\(k\)</span>-cycle.</p>
<p>Proof of claim: If <span class="math inline">\(G&#39;\)</span> has a cycle then dropping the directionality won’t kill the cycle. If the cycle in <span class="math inline">\(G&#39;&#39;\)</span> uses a vertex from each of the <span class="math inline">\(k\)</span> parts <span class="math inline">\(V_i\)</span> then it is clearly a cycle in <span class="math inline">\(G&#39;\)</span>. Assume for contradiction that there is a cycle in <span class="math inline">\(G&#39;&#39;\)</span> that doesn’t use some part <span class="math inline">\(V_i\)</span>. But <span class="math inline">\(G&#39;&#39;\setminus V_i\)</span> is bipartite, so it cannot contain an odd cycle.</p>
<figure>
<img src="src/images/graph2.png" alt="" /><figcaption>Depictionn of the layered grahp</figcaption>
</figure>
<figure>
<img src="src/images/graph3.png" alt="" /><figcaption>Why this breaks if k is even</figcaption>
</figure>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> Let <span class="math inline">\(k\)</span> be a constant. Directed-<span class="math inline">\(k\)</span>-cycle is equivalently hard to triangle detection.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> We already showed how to solve directed-<span class="math inline">\(k\)</span>-cycle with MM.</p>
<p>Let <span class="math inline">\(G = (V, E)\)</span> be a graph we want to do triangle detection in. Make <span class="math inline">\(k\)</span> copies of the vertex set: <span class="math inline">\(V_1,V_2,\ldots, V_k\)</span>. We denote the copies of a vertex <span class="math inline">\(v\)</span> by <span class="math inline">\(v_1,v_2,\ldots, v_k\)</span>.</p>
<ul>
<li><p>Connect <span class="math inline">\(u_1\to v_2 \in V_1 \times V_2\)</span> iff <span class="math inline">\((u,v)\in E(G)\)</span>.</p></li>
<li><p>Connnect <span class="math inline">\(u_k\to v_1 \in V_{k}\times V_1\)</span> iff <span class="math inline">\((u,v) \in E(G)\)</span></p></li>
<li><p>For each <span class="math inline">\(i\in [2, k-1]\)</span> and each vertex <span class="math inline">\(v\in V\)</span> connect <span class="math inline">\(v_i\to v_{i+1}\in V_i \times V_{i+1}\)</span>.</p>
<p>A <span class="math inline">\(k\)</span>-cycle in this new graph corresponds to a triangle in the original graph.</p></li>
</ul>
</div>
<h1 id="girth">Girth</h1>
<p><strong>GIRTH</strong>: length of shortest cycle</p>
<h3 id="approx-in-n2-time"><span class="math inline">\(1.5\)</span>-approx in <span class="math inline">\(n^2\)</span> time</h3>
<div class="thm envbox">
<p><strong>Theorem.</strong> <strong>Theorem</strong>: you can <span class="math inline">\(1.5\)</span>-approximate shortest cycle in <span class="math inline">\(n^{2}\)</span> time. That is, you either</p>
<ul>
<li>if any cycle of length <span class="math inline">\(\le g\)</span> exists, output a cycle of length <span class="math inline">\(\le 1.5g\)</span></li>
<li>if no cycle of length <span class="math inline">\(\le g\)</span> exists, no guarantee.</li>
</ul>
</div>
<div class="rmk envbox">
<p><strong>Remark.</strong> If you want to turn the decision problem stated above into actually an algorithm for finding the shortest cycle, then you can do the standard binary search trick.</p>
</div>
<hr />
<div class="pf envbox">
<p><strong>Proof.</strong></p>
<p>wlog <span class="math inline">\(|E(G)|\le n^{1.5}\)</span> or else we instantly have a <span class="math inline">\(4\)</span>-cycle.</p>
<p>Let <span class="math inline">\(B\)</span> be the ball of radius <span class="math inline">\(\frac{g}{4}\)</span> aroud some point <span class="math inline">\(x\)</span> on the shortest cycle.</p>
<p><strong>Case 1</strong>: <span class="math inline">\(|B| \ge \sqrt{n}\)</span> Then, if we randomly sample a subset <span class="math inline">\(S\)</span> of size <span class="math inline">\(\sqrt{n}\log n\)</span> we intersect with <span class="math inline">\(B\)</span> with high probability. Imagine we ran BFS-cycle out of <span class="math inline">\(y\in B\)</span>. Then we would find a cycle of length at most <span class="math inline">\(1.5 g\)</span>. So what we do is run BFS-cycle out of all the points in <span class="math inline">\(S\)</span>. The cost of this is <span class="math inline">\(\sqrt{n} m \le n^{2}\)</span>.</p>
<p><strong>Case 2:</strong> <span class="math inline">\(B\)</span> is pretty small <span class="math inline">\(|B| &lt; \sqrt{n}\)</span> Run a BFS out of each point for <span class="math inline">\(\frac{g}{4}\)</span> steps.</p>
<p>Intuitively what you do is basically construct a graph where vertices are connected if they are connected by a length <span class="math inline">\(\frac{g}{4}\)</span> path in the original graph. The way you compute this new graph is you BFS out of each vertex. But now the BFS is better because we know we can quit if the ball gets larger than <span class="math inline">\(\sqrt{n}\)</span> because we are assuming that we aren’t in case 1. Then you could run <span class="math inline">\(4\)</span>-cycle detection on it. Of course that’s not really how life works, because that might accidentally find a path, but apparently this is fixable.</p>
<p>Constructing this graph costs <span class="math inline">\(n\sqrt{n}\)</span>. Doing the four-cycle detection takes <span class="math inline">\(n^{2}\)</span>.</p>
<p>By doing both case 1 and case 2 we get a <span class="math inline">\(1.5\)</span>-approximation in <span class="math inline">\(n^{2}\)</span> time.</p>
</div>
<hr />
<h3 id="a-worse-algorithm">A worse algorithm:</h3>
<div class="prop envbox">
<p><strong>Proposition.</strong> 2-approx in <span class="math inline">\(n^2\)</span> time.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> Let <span class="math inline">\(G=(V, E)\)</span>. form a new graph with vertex sets <span class="math inline">\(V, V&#39;\)</span>. make an edge <span class="math inline">\(xy&#39; \in G&#39;\)</span> for <span class="math inline">\(x\in V, y&#39;\in V&#39; \iff xy\in E(G)\)</span>. So <span class="math inline">\(G&#39;\)</span> is bipartite. claim: If G’ has a cycle of length <span class="math inline">\(k\)</span> then G has a cycle of length at least <span class="math inline">\(k/2\)</span>. proof: I brute-forced k=6. It seems like it should be true in general.</p>
<p>recall: “even cycles even faster”: we can find even cycles (even is redundant because G’ is bipartite but whatever) in G’ in <span class="math inline">\(n^2\)</span> time.</p>
</div>
<div class="rmk envbox">
<p><strong>Remark.</strong> this is strictly worse in every way (except maybe simplicity) than the <span class="math inline">\(1.5\)</span>-approx in <span class="math inline">\(n^{2}\)</span> time proved above.</p>
</div>
<h3 id="approx-in-n2-19-time"><span class="math inline">\(4\)</span>-approx in <span class="math inline">\(n^{2-1/9}\)</span> time</h3>
<div class="thm envbox">
<p><strong>Theorem.</strong> <span class="math inline">\(4\)</span>-approx in <span class="math inline">\(n^{2-1/9}\)</span> time</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> PoC: if <span class="math inline">\(G\)</span> contains a triangle we want to output a cycle of length at most <span class="math inline">\(12\)</span>. Else, we provide no guarantees.</p>
<p>I’ll just do the PoC. But I’m pretty sure stuff should work out strictly better if the min cycle we are worrying about is larger.</p>
<p>If <span class="math inline">\(m\ge n^{\frac{7}{6}}\)</span> then it’s probably really easy to find a <span class="math inline">\(12\)</span>-cycle. So lets assume this is not the case, i.e., <span class="math inline">\(m\le n^{\frac{7}{6}}\)</span>. Now, we do the high-degree low-degree business. That is, let <span class="math inline">\(H\)</span> be the high-degree threshold. There are at most <span class="math inline">\(\frac{m}{H}\)</span> high-degree vertices, so BFS-ing over all of these costs at most <span class="math inline">\(\frac{m^{2}}{H}\)</span>. For low-degree vertices we do fancy BFS where we ignore high-degree vertices. This costs <span class="math inline">\(nH^{2}\)</span> (two levels of BFS for fiding triangles.) Balancing this gives: <span class="math display">\[\frac{m}{H}m = nH^{2}  \implies H = (m^{2} / n)^{\frac{1}{3}}
 = n^{\frac{4}{9}}.\]</span></p>
<p>Then the cost is <span class="math inline">\(nH^{2} = n^{2-\frac{1}{9}}.\)</span></p>
</div>
<h3 id="additive-1-approximation-for-girth-in-n2-time">additive <span class="math inline">\(1\)</span>-approximation for girth in <span class="math inline">\(n^2\)</span> time</h3>
<div class="thm envbox">
<p><strong>Theorem.</strong> Given a graph <span class="math inline">\(G\)</span> of girth <span class="math inline">\(g\)</span> we will find a cycle of length at most <span class="math inline">\(g+1\)</span> in time <span class="math inline">\(O(n^{2})\)</span>. Futhermore, if <span class="math inline">\(g\)</span> is even the cycle we find will actually be of length <span class="math inline">\(g\)</span>.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> Algorithm: BFS-Cycle out of every vertex. Run time: <span class="math inline">\(O(n^{2})\)</span>.</p>
</div>
<h3 id="exact-algorithm-for-girth-in-nomega-time">Exact Algorithm for Girth in <span class="math inline">\(n^{\omega}\)</span> time</h3>
<div class="thm envbox">
<p><strong>Theorem.</strong> Exact Algorithm for Girth in <span class="math inline">\(n^{\omega}\)</span> time.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> First run the additive <span class="math inline">\(1\)</span>-approximation.</p>
<p>If it outputs a cycle of odd length we know it is equal to the girth. Else, call the length of the ouput cycle <span class="math inline">\(2\ell\)</span>. The girth is either <span class="math inline">\(2\ell\)</span> or <span class="math inline">\(2\ell-1\)</span>.</p>
<p>So, now we would just like to determine whether <span class="math inline">\(G\)</span> has a cycle of length <span class="math inline">\(2\ell-1\)</span>. At the beginning of this blog post we showed how to solve this with <span class="math inline">\(2\ell-2\)</span> matrix multiplications. But that’s not going to cut it here, we don’t really have a bound on <span class="math inline">\(\ell\)</span>.</p>
<p>Here’s how we construct a triangle-detection instance: Make a new graph <span class="math inline">\(G&#39;\)</span>. Place <span class="math inline">\(G\)</span> in <span class="math inline">\(G&#39;\)</span>. Then create copies of the vertices. Connect <span class="math inline">\(v\in V(G)\)</span> and copy the copy <span class="math inline">\(w&#39;\)</span> of <span class="math inline">\(w\in V(G)\)</span> if <span class="math inline">\(dist(v, w)=\ell-1\)</span>. We know this distance because of our BFS-ing.</p>
<p><span class="math inline">\(G&#39;\)</span> has a triangle iff <span class="math inline">\(G\)</span> has an <span class="math inline">\((2\ell-1)\)</span>-cycle. <img src="src/images/ink_img002.png" alt="ink_img002" /></p>
</div>

      </div>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full"></script>
    <script src="../../formatting/scrolling-nav.js"></script>

    <script charset="utf-8">
        var pres = document.querySelectorAll("pre>code");
        for (var i = 0; i < pres.length; i++) {
            hljs.highlightBlock(pres[i]);
        }
    </script>

    <div id="disqus_thread"></div>
    <script>
      /**
      *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
      *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
      /*
      var disqus_config = function () {
      this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
      };
      */
      (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://awestovergithubioskyspace.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    <script id="dsq-count-scr" src="//awestovergithubioskyspace.disqus.com/count.js" async></script>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-P9YVJX8W9R"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-P9YVJX8W9R');
</script>

  </body>
</html>
