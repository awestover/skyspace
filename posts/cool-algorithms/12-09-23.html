<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <title>skyspace</title>

    <link href="../../formatting/pandoc.css" rel="stylesheet">
    <link href="../../formatting/envbox.css" rel="stylesheet">
    <link href="../../formatting/bars.css" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.4.1/jquery.easing.min.js" integrity="sha256-H3cjtrm/ztDeuhCN9I4yh4iN2Ybx/y1RM7rMmAesA0k=" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>

  </head>
  <body>
    <div class="wrapper">
      <nav id="sidebar">
        <div id="sidebar-content">
          <div class="sidebar-header">
            <h5>skyspace</h5>
          </div>
          <ul class="list-unstyled components">
            <img style="width:100%; max-width:250px" src="../../images/cat.png" alt="cat"/>
            <li> <a href="../../index.html">Home</a> </li>
            <li> <a href="../../about.html">About</a> </li>
            <li> <a href="../../topics.html">Topics</a> </li>
            <hr>
            <div id="toc">
            <li> <a href="#general-notes-on-exact-cycle-finding
" class="js-scroll-trigger">General Notes on Exact Cycle Finding
</a> </li>
<li> <a href="#finding-even-cycles
" class="js-scroll-trigger">Finding Even Cycles
</a> </li>
<li> <a href="#girth
" class="js-scroll-trigger">Girth
</a> </li>
<li> <a href="#some-not-so-good-algorithms-that-i-made-up
" class="js-scroll-trigger">some not-so-good algorithms that I made up
</a> </li>
<li> <a href="#relatively-old-work-on-girth-approximation
" class="js-scroll-trigger">relatively old work on girth approximation
</a> </li>
<li> <a href="#cutting-edge-approximations
" class="js-scroll-trigger">cutting-edge approximations
</a> </li>
            </div>
          </ul>
        </div>
      </nav>

      <div id="content"> 
      <p>The topic today is taken from <a href="https://people.csail.mit.edu/virgi/6.890/">Virginia Williams’ MM + Graph Algs lecture notes</a>. Throughout the post <span class="math inline">\(\omega&lt;2.4\)</span> is the matrix multiplication exponent. MM will stand for matrix multiplication.</p>
<h1 id="general-notes-on-exact-cycle-finding">General Notes on Exact Cycle Finding</h1>
<div class="thm envbox">
<p><strong>Theorem.</strong> Let <span class="math inline">\(k\in \mathbb{N}_{\ge 3}\)</span> be a constant. directed/undirected-<span class="math inline">\(k\)</span>-cycle detection can be accomplished in <span class="math inline">\(n^{\omega}\)</span> time on <span class="math inline">\(n\)</span>-vertex graphs.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> It suffices to prove the theorem for directed graphs. We won’t need to explicitely mention this throughout the proof, but just note that the adjacency matrices needn’t be symmetric.</p>
<p>For <span class="math inline">\(k=3\)</span> you can just cube the adjacency matrix and check whether its trace is <span class="math inline">\(0\)</span>. This doesn’t work for <span class="math inline">\(k&gt;3\)</span> because powers of the adjacency matrix count walks, i.e., are allowed to repeat vertices.</p>
<p>Instead we do color coding! Color with <span class="math inline">\(k\)</span> colors. Make matrices <span class="math inline">\(A_1,A_2,\ldots, A_{k-1}\)</span> where <span class="math inline">\(A_i\)</span> represents the transition from color <span class="math inline">\(i\)</span> vertices to color <span class="math inline">\(i+1\)</span> vertices. That is, fix some ordering of the vertices within each color class, and then make the rows of <span class="math inline">\(A_i\)</span> be the vertices of color <span class="math inline">\(i\)</span> and the columns of <span class="math inline">\(A_i\)</span> be the vertices of color <span class="math inline">\(i+1\)</span>, and place edges if the vertices are adjacent.</p>
<p>Let <span class="math inline">\(B = A_1\cdot A_2\cdots A_{k-1}\)</span>; <span class="math inline">\(B\)</span> can be computed in <span class="math inline">\(n^{\omega}\)</span> time. <span class="math inline">\(B[u,v]\)</span> counts the number of <span class="math inline">\(k\)</span>-vertex paths from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span> whose vertices are colors <span class="math inline">\(1,2,\ldots, k\)</span>.</p>
<p>Now, for each <span class="math inline">\(u,v\)</span> check whether <span class="math inline">\(A[v,u]=1 \land B[u,v]&gt;0\)</span>. If the check ever passes then we have found a <span class="math inline">\(k\)</span>-cycle.</p>
<p>If the cycle was correctly colored we must find a <span class="math inline">\(k\)</span>-cycle in this manner.</p>
<p>The coloring succeeds with probability <span class="math inline">\(\frac{1}{k^{k}}\ge \Omega(1)\)</span>. Taking <span class="math inline">\(\Omega(\log n)\)</span> tries for the coloring lets us succeed at least once with high probability.</p>
<figure>
<img src="src/images/graph1.png" alt="" /><figcaption>src/images/graph1.png</figcaption>
</figure>
</div>
<p>It turns out that even cycle detection can be done in <span class="math inline">\(n^{2}\)</span> time in undirected graphs. Now I establish that odd cycle detection does require <span class="math inline">\(n^{\omega}\)</span> time. First we prove another interesting result:</p>
<div class="thm envbox">
<p><strong>Theorem.</strong> Let <span class="math inline">\(k\)</span> be an odd constant. Then directed-<span class="math inline">\(k\)</span>-cycle is equivalently hard to undirected-<span class="math inline">\(k\)</span>-cycle.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> We can convert an instance of undirected-<span class="math inline">\(k\)</span>-cycle to directed-<span class="math inline">\(k\)</span>-cycle by thinking of each edge <span class="math inline">\(\left\{ u,v\right\}\)</span> as being two directed edges <span class="math inline">\(u\to v\)</span> and <span class="math inline">\(v\to u\)</span>.</p>
<p>The other direction is more subtle. We are given an instance of directed-<span class="math inline">\(k\)</span>-cycle. By color coding we assume that the graph has parts <span class="math inline">\(V_1,V_2,\ldots, V_k\)</span> and we only consider edges from <span class="math inline">\(V_i\to V_{i+1}\)</span>. Let this new graph be <span class="math inline">\(G&#39;\)</span>.</p>
<p>Let <span class="math inline">\(G&#39;&#39;\)</span> be the graph obtained by dropping the directionality on the edges in <span class="math inline">\(G&#39;\)</span>.</p>
<p><strong>Claim</strong>: <span class="math inline">\(G&#39;&#39;\)</span> has an undirected-<span class="math inline">\(k\)</span>-cycle iff colorful <span class="math inline">\(G&#39;\)</span> has a directed <span class="math inline">\(k\)</span>-cycle.</p>
<p>Proof of claim: If <span class="math inline">\(G&#39;\)</span> has a cycle then dropping the directionality won’t kill the cycle. If the cycle in <span class="math inline">\(G&#39;&#39;\)</span> uses a vertex from each of the <span class="math inline">\(k\)</span> parts <span class="math inline">\(V_i\)</span> then it is clearly a cycle in <span class="math inline">\(G&#39;\)</span>. Assume for contradiction that there is a cycle in <span class="math inline">\(G&#39;&#39;\)</span> that doesn’t use some part <span class="math inline">\(V_i\)</span>. But <span class="math inline">\(G&#39;&#39;\setminus V_i\)</span> is bipartite, so it cannot contain an odd cycle.</p>
<figure>
<img src="src/images/graph2.png" alt="" /><figcaption>Depictionn of the layered grahp</figcaption>
</figure>
<figure>
<img src="src/images/graph3.png" alt="" /><figcaption>Why this breaks if k is even</figcaption>
</figure>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> Let <span class="math inline">\(k\)</span> be a constant. Directed-<span class="math inline">\(k\)</span>-cycle is equivalently hard to triangle detection.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> We already showed how to solve directed-<span class="math inline">\(k\)</span>-cycle with MM.</p>
<p>Let <span class="math inline">\(G = (V, E)\)</span> be a graph we want to do triangle detection in. Make <span class="math inline">\(k\)</span> copies of the vertex set: <span class="math inline">\(V_1,V_2,\ldots, V_k\)</span>. We denote the copies of a vertex <span class="math inline">\(v\)</span> by <span class="math inline">\(v_1,v_2,\ldots, v_k\)</span>.</p>
<ul>
<li><p>Connect <span class="math inline">\(u_1\to v_2 \in V_1 \times V_2\)</span> iff <span class="math inline">\((u,v)\in E(G)\)</span>.</p></li>
<li><p>Connnect <span class="math inline">\(u_k\to v_1 \in V_{k}\times V_1\)</span> iff <span class="math inline">\((u,v) \in E(G)\)</span></p></li>
<li><p>For each <span class="math inline">\(i\in [2, k-1]\)</span> and each vertex <span class="math inline">\(v\in V\)</span> connect <span class="math inline">\(v_i\to v_{i+1}\in V_i \times V_{i+1}\)</span>.</p>
<p>A <span class="math inline">\(k\)</span>-cycle in this new graph corresponds to a triangle in the original graph.</p></li>
</ul>
</div>
<hr />
<h1 id="finding-even-cycles">Finding Even Cycles</h1>
<div class="thm envbox">
<p><strong>Theorem.</strong> “Even cycles Even Faster”</p>
<ol type="1">
<li>For all <span class="math inline">\(k\)</span>, there is an <span class="math inline">\(n^{2}\)</span> algorithm to detect existence of a <span class="math inline">\(2k\)</span> cycle (and find it, if it exists).</li>
<li>There is an <span class="math inline">\(n^{2}\)</span> time algorithm to find the shortest even cycle.</li>
</ol>
</div>
<p>First I present two simple proofs of the theorem for <span class="math inline">\(k=2\)</span>. Then I’ll present a proof for general <span class="math inline">\(k\)</span>.</p>
<div class="thm envbox">
<p><strong>Theorem.</strong> <span class="math inline">\(4\)</span>-cycle, <span class="math inline">\(n^{2}\)</span> time.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> 1. Common neighbor(x,y): make an <span class="math inline">\(n \times n\)</span> matrix <span class="math inline">\(A\)</span>. <span class="math inline">\(A[i,j]\)</span> will store whether we have found a common neighbor for <span class="math inline">\(i,j\)</span> so far. If any cell in the matrix ever gets hit twice then we found a <span class="math inline">\(4\)</span>-cycle. What we do is, for each vertex <span class="math inline">\(v\)</span>, for each pair of vertices in <span class="math inline">\(N(v)\)</span> mark them as having a common neighbor.</p>
<ol start="2" type="1">
<li><p>wlog its bipartite: In particular, take <span class="math inline">\(G=(V,E)\)</span>, and form <span class="math inline">\(G&#39;\)</span> by duplicating the vertex set to <span class="math inline">\(V\sqcup V&#39;\)</span> and put an edge between <span class="math inline">\(uv&#39;\)</span> if <span class="math inline">\(uv\)</span> is an edge in <span class="math inline">\(G\)</span>. Then, if you had a <span class="math inline">\(4\)</span>-cycle in <span class="math inline">\(G\)</span> it is converted into a <span class="math inline">\(4\)</span>-cycle in <span class="math inline">\(G&#39;\)</span>. But of course <span class="math inline">\(G&#39;\)</span> is bipartite and only a constant-factor larger. Then, run BFS-cycle out of each vertex (for depth <span class="math inline">\(2\)</span>). This must terminate fast. More precisely, for all vertices in the neighbor-set of one of your vertices color their left-neighbors. If a left-neighbor gets colored twice it means you have a <span class="math inline">\(C_4\)</span>.</p></li>
<li><p>Again, lets just work in bipartite graphs. wlog by Bond Simonivitis <span class="math inline">\(m\le 200 n^{1.5}\)</span>. Do a 2 step BFS out of some vertex <span class="math inline">\(v\)</span> with degree <span class="math inline">\(\ge \sqrt{n}\)</span>. If we found a <span class="math inline">\(4\)</span>-cycle then that’s lovely. Else, itterate over all <span class="math inline">\(w\in RHS\)</span> and check if any of them have two neighbors in <span class="math inline">\(N(u)\)</span> for any <span class="math inline">\(u\in N(v)\)</span>. This will take <span class="math inline">\(n^{1.5}\)</span> time. If any of the checks pass, we get a <span class="math inline">\(4\)</span>-cycle. Else, we can delete the vertices <span class="math inline">\(N(v)\)</span>: they are not part of any four-cycles. The gist is we keep paying <span class="math inline">\(n^{1.5}\)</span> to kick <span class="math inline">\(\sqrt{n}\)</span> vertices. Should pay <span class="math inline">\(n^{2}\)</span> to kick all <span class="math inline">\(n\)</span> vertices.</p></li>
</ol>
<p><strong>You can also get better results if your graph is extra sparse.</strong> 4. For instance, here’s an <span class="math inline">\(O(nm^{2/3})\)</span> time algorithm: BFS-cycle out of all vertices with more than <span class="math inline">\(m^{1/3}\)</span> degree, do a restricted BFS-cycle ignoring high degree vertices out of all vertices. Costs <span class="math display">\[\frac{m}{H} n + nH^{2}.\]</span> IMPORTANT: first make your graph bipartite before you do this, to kill triangles.</p>
<ol start="5" type="1">
<li><span class="math inline">\(m\sqrt{n}\)</span> algorithm: again, we are going to assume bipartite (we can make a bipartite instance in <span class="math inline">\(O(m+n)\)</span> time so this is legal; could also argue by color coding but that’s overkill).</li>
</ol>
<ul>
<li><p>BFS-cycle out of all vertices with degree larger than <span class="math inline">\(\sqrt{n}\)</span></p></li>
<li><p>Now we only focus on vertices of degree smaller than <span class="math inline">\(\sqrt{n}\)</span></p></li>
<li><p>for <span class="math inline">\((v,w)\in E(g)\)</span></p>
<ul>
<li>for <span class="math inline">\(x\in N(v)\)</span>
<ul>
<li>Mark <span class="math inline">\(x,w\)</span> as friends, unless they were already friends in which case we have a <span class="math inline">\(4\)</span>-cycle. Run time is <span class="math display">\[\frac{m}{\sqrt{n}}n + m\sqrt{n}.\]</span></li>
</ul></li>
</ul></li>
</ul>
<ol start="6" type="1">
<li><span class="math inline">\(O(m^{4/3}\)</span> algorithm (ok, we’re assuming <span class="math inline">\(m\ge n\)</span>, here and always and forever)</li>
</ol>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>degrees <span class="op">=</span> [array storing <span class="bu">hash</span><span class="op">-</span>sets of which vertices are of each degree]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>my_degree <span class="op">=</span> [lookup table, <span class="cf">for</span> each vertex tells you where it <span class="kw">is</span> <span class="kw">in</span> the degree table]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="cf">while</span> there are vertices <span class="cf">with</span> degree <span class="op">&lt;</span> <span class="dv">200</span> m<span class="op">^</span>{<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>}:</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  delete some such vertex w</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  modify the degrees of the neighbors of w appropriately</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="cf">if</span> this resulted <span class="kw">in</span> a non<span class="op">-</span>empty graph:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>  we have <span class="bu">super</span><span class="op">-</span>saturation <span class="kw">in</span> this graph, <span class="kw">and</span> insta<span class="op">-</span>win</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>  Let v1,v2,... be the order that we deleted vertices <span class="kw">in</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>  <span class="cf">for</span> v <span class="op">=</span> v1,v2, etc:</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>    <span class="cf">for</span> each pair (a,b) <span class="kw">in</span> N(v):</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>      mark a,b <span class="im">as</span> friends, </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>      unless they are already friends,</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>      <span class="kw">in</span> which case we found a <span class="dv">4</span> cycle</span></code></pre></div>
<p>The correctness of this algorithm is pretty clear. Now we analyze its performance.</p>
<p>First, assume that the resulting graph after the deletions is non-empty. It costs <span class="math inline">\(m^{1/3}\)</span> to delete a vertex, because the vertex has low degree and we must update its neighbor’s degree counters. Finding the minimum degree vertex is always super cheap because we keep a sorted list. The super-saturation stuff is super cheap. So we pay <span class="math inline">\(nm^{1/3}\le m^{4/3}\)</span> in this case.</p>
<p>Now, assume that the resulting graph after the deletions turns out to be empty. Then, we claim that if we do the construction from the previous method a bit more carefully stuff will work. You might hope that we can just immediately use the previous construction. But its not the case that all vertices have degree smaller than <span class="math inline">\(m^{1/3}\)</span> here, they just did after some deletions. So, we will process vertices in this same order and achieve the same bound. Specifically, if we deleted the vertices in the order <span class="math inline">\(v_1,v_2,v_3,\ldots\)</span> we first handle the edges out of <span class="math inline">\(v_1\)</span>, then delete <span class="math inline">\(v_1\)</span> and handle the edges out of <span class="math inline">\(v_2\)</span> etc. And when I say delete I really do mean clean up the adjacency lists of all of <span class="math inline">\(v_1\)</span>’s friends; this should be find seeing as there are not so many of them. Anyways with this method you repeatedly take time <span class="math inline">\(|N(v_i)|^{2}\)</span> (note it’s the number of neighbors after we have already deleted some neighbors) to kill <span class="math inline">\(|N(v_i)|\)</span> edges. But of course we have our degree constraint. So the worse time-edge-killed tradeoff possible is <span class="math inline">\(m^{1/3}\)</span> edges per <span class="math inline">\(m^{2/3}\)</span> time. But even this way we will kill all edges after <span class="math inline">\(m^{2/3}\)</span> steps. So we win in time <span class="math inline">\(m^{4/3}\)</span>.</p>
<figure>
<img src="src/images/ink_img005.png" alt="" /><figcaption>ink_img005</figcaption>
</figure>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> An <span class="math inline">\(\widetilde{O}(n^{2})\)</span> time algo for <span class="math inline">\(6\)</span>-cycle.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> Important fact: any connected graph with average degree at least <span class="math inline">\(4\)</span> has a <span class="math inline">\(4\)</span>-edge path emenating from every vertex.</p>
<p>Corollary: in any graph <span class="math inline">\(G\)</span> with average degree at least <span class="math inline">\(4\)</span> we can find a <span class="math inline">\(4\)</span>-edge path in <span class="math inline">\(G\)</span> in linear time. Proof: First, if the edge density of <span class="math inline">\(G\)</span> is more than <span class="math inline">\(n^{.1}\)</span> we can do it by super-saturation in <span class="math inline">\(\log n\)</span> time with high probability. Else, just do a <span class="math inline">\(2\)</span>-step BFS (not BFS cycle) out of some vertex. And then its pretty easy.</p>
<p>We give an <span class="math inline">\(\widetilde{O}(n)\)</span> algorithm that given a vertex <span class="math inline">\(v\)</span> contained in a <span class="math inline">\(6\)</span>-cycle outputs a <span class="math inline">\(6\)</span>-cycle not-necessarily containing <span class="math inline">\(v\)</span>.</p>
<p>We BFS but we quit if there is every average degree at least <span class="math inline">\(4\)</span> within a level of BFS or between levels of BFS. More particularly, let <span class="math inline">\(L_1,L_2,L_3\)</span> be the levels of BFS.</p>
<p>Let <span class="math inline">\(G[L_i]\)</span> denote the induced subgraph on vertices <span class="math inline">\(L_i\)</span> and let <span class="math inline">\(G[L_i, L_{i+1}]\)</span> denote the bipartite subgraph consisting of edges with one endpoint in <span class="math inline">\(L_i\)</span> and the other endpoint in <span class="math inline">\(L_{i+1}\)</span>.</p>
<ul>
<li><p>Case 1: <span class="math inline">\(G[L_1]\)</span> has average degree at least <span class="math inline">\(4\)</span>. Then, find a connected component of <span class="math inline">\(G[L_1]\)</span> with average degree at least <span class="math inline">\(4\)</span>; this can be done in linear time. Then, find a <span class="math inline">\(4\)</span>-edge path in this connected component of <span class="math inline">\(G[L_1]\)</span> and connect it to the BFS root <span class="math inline">\(v\)</span>: it’s a <span class="math inline">\(6\)</span>-cycle!</p></li>
<li><p>Case 2: <span class="math inline">\(G[L_1, L_2]\)</span> has average degree at least <span class="math inline">\(4\)</span>. Then, find a <span class="math inline">\(4\)</span>-path in a connected component of <span class="math inline">\(G[L_1, L_2]\)</span> with average degree at least <span class="math inline">\(4\)</span> and connect it to the BFS root <span class="math inline">\(v\)</span>: it’s a <span class="math inline">\(6\)</span>-cycle. Note the key fact that a <span class="math inline">\(4\)</span>-edge path in a bipartite graph starts and ends in the same part.</p></li>
<li><p>Case 3: <span class="math inline">\(G[L_2]\)</span> has average degree at least <span class="math inline">\(4\)</span>. Here we need a picture: <img src="src/images/ink_img006.png" alt="ink_img006" /> Basically, you find a <span class="math inline">\(4\)</span>-path. If it contains a <span class="math inline">\(2\)</span>-path that is connected to <span class="math inline">\(2\)</span> separate vertices from <span class="math inline">\(L_1\)</span> then that gives a <span class="math inline">\(6\)</span>-cycle. If the <span class="math inline">\(4\)</span>-path’s endpoints are connected to the same vertex in <span class="math inline">\(L_1\)</span> we also get a <span class="math inline">\(6\)</span>-cycle. Finally, if both of the above things fail we get a <span class="math inline">\(6\)</span>-cycle on the other end. Or rather I should say, it is impossible for both of these things to fail.</p></li>
<li><p>Case 4: <span class="math inline">\(G[L_2, L_3]\)</span> has average degree at least <span class="math inline">\(4\)</span>. Again this is great because this is bipartite so a <span class="math inline">\(4\)</span>-path in it works ust the same way as a <span class="math inline">\(4\)</span>-path in <span class="math inline">\(G[L_2]\)</span> from case 3.</p></li>
<li><p>Case 5: Now, assuming all that stuff didn’t happen, we can win in time <span class="math inline">\(n\log n\)</span> with high probability.</p>
<p>Let’s mark the vertices in <span class="math inline">\(L_2\)</span> by which vertex from <span class="math inline">\(L_1\)</span> they are reachable from. If a vertex in <span class="math inline">\(L_2\)</span> is reachable from multiple <span class="math inline">\(L_1\)</span> vertices, call that vertex <strong>extra-nice</strong>.</p>
<p>Then we want to find a vertex in <span class="math inline">\(L_3\)</span> that is hit by two <span class="math inline">\(L_2\)</span> vertices with distinct labels. E.g., a <span class="math inline">\(v_1\)</span>-reachable and a <span class="math inline">\(v_2\)</span>-reachable <span class="math inline">\(L_2\)</span> vertex or an extra-nice vertex and any other vertex. Seems like this should be <span class="math inline">\(O(n)\)</span> time because there are <span class="math inline">\(O(n)\)</span> edges emenating from <span class="math inline">\(L_2\)</span>.</p>
<p><strong>TODO: I think I must be wrong here, because this is quite a bit stronger than what the pset asked for.</strong></p></li>
</ul>
</div>
<strong>Broken proof</strong> for general <span class="math inline">\(k\)</span>
<div class="pf envbox">
<p><strong>Proof.</strong> <strong>EDIT: no this is not quite right. the problem is, BFS-cycle might return a smaller cycle than our target size!! so this doesn’t work. CAUTION.</strong></p>
<p>goal: check whether our graph contains a <span class="math inline">\(2k\)</span>-cycle Note: wlog <span class="math inline">\(m\le 200 n^{1+\frac{1}{k}}\)</span> or else we are guaranteed to have a <span class="math inline">\(2k\)</span>-cycle (even, super-saturation of <span class="math inline">\(2k\)</span>-cycles. anyways, we can find them.)</p>
<p><strong>Case 1:</strong> There exists a high degree vertex, say with degree larger than <span class="math inline">\(H\)</span> somewhere on the cycle. There aren’t so many vertices like this. It costs <span class="math inline">\(\frac{m}{H} n\)</span> to just BFS-cycle out of all the high degree vertices.</p>
<p><strong>Case 2</strong>: Negation of case 1. i.e., all vertices on the cycle have degree smaller than <span class="math inline">\(H\)</span>. Then we can do BFS-cycle a bit more efficiently, in time <span class="math inline">\(n H^{k}\)</span>.</p>
<p>Balancing (1) and (2) gives:</p>
<p><span class="math display">\[ \frac{m}{H}n = nH^{k} \implies H = m^{1/(k+1)}.\]</span></p>
<p>This yields running time <span class="math display">\[n m^{k/(k+1)} \le n n^{(1+1/k)(k/(k+1))} = n^{2}.\]</span></p>
</div>
<h1 id="girth">Girth</h1>
<p><strong>GIRTH</strong>: length of shortest cycle</p>
<h2 id="some-not-so-good-algorithms-that-i-made-up">some not-so-good algorithms that I made up</h2>
<div class="prop envbox">
<p><strong>Proposition.</strong> 2-approx in <span class="math inline">\(n^2\)</span> time. remark: This is kind of bad, we can get a <span class="math inline">\(+1\)</span> approx in <span class="math inline">\(n^{2}\)</span> time lol.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> Let <span class="math inline">\(G=(V, E)\)</span>. form a new graph with vertex sets <span class="math inline">\(V, V&#39;\)</span>. make an edge <span class="math inline">\(xy&#39; \in G&#39;\)</span> for <span class="math inline">\(x\in V, y&#39;\in V&#39; \iff xy\in E(G)\)</span>. So <span class="math inline">\(G&#39;\)</span> is bipartite. claim: If G’ has a cycle of length <span class="math inline">\(k\)</span> then G has a cycle of length at least <span class="math inline">\(k/2\)</span>. proof: I brute-forced k=6. It seems like it should be true in general.</p>
<p>recall: “even cycles even faster”: we can find even cycles (even is redundant because G’ is bipartite but whatever) in G’ in <span class="math inline">\(n^2\)</span> time.</p>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> There is an algorithm that, on graphs of girth <span class="math inline">\(g\le 100\)</span> outputs a cycle of length at most <span class="math inline">\(g+25\)</span> in time <span class="math inline">\(O(n^{1.999})\)</span></p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong></p>
<p>If <span class="math display">\[m \ge \Omega( n^{1+ \frac{1}{\left\lfloor (g+25)/2 \right\rfloor} }) \]</span> then we have super-saturation of <span class="math inline">\(2\left\lfloor (g+25)/2 \right\rfloor\)</span>-cycles. So wlog may assume this is not the case. Now, high-deg low-deg cases.</p>
<ul>
<li>High deg cost: <span class="math inline">\(n\cdot m/H\)</span>.</li>
<li>Low deg cost: <span class="math inline">\(n\cdot H^{\left\lceil g/2 \right\rceil}\)</span>.</li>
</ul>
<p>Balancing: <span class="math display">\[H = m^{\frac{1}{\left\lceil g/2 \right\rceil+1}}.\]</span></p>
<p>So the cost is <span class="math display">\[n m^{ \frac{\left\lceil g/2 \right\rceil}{\left\lceil g/2 \right\rceil+1} } \le n n^{\frac{\left\lceil g/2 \right\rceil}{\left\lceil g/2 \right\rceil+1}  \cdot (1+\frac{1}{\left\lfloor (g+25)/2 \right\rfloor})}.\]</span></p>
<p>not clear how good this is.</p>
</div>
<h2 id="relatively-old-work-on-girth-approximation">relatively old work on girth approximation</h2>
<h3 id="additive-1-approximation-for-girth-in-n2-time">additive <span class="math inline">\(1\)</span>-approximation for girth in <span class="math inline">\(n^2\)</span> time</h3>
<div class="thm envbox">
<p><strong>Theorem.</strong> Given a graph <span class="math inline">\(G\)</span> of girth <span class="math inline">\(g\)</span> we will find a cycle of length at most <span class="math inline">\(g+1\)</span> in time <span class="math inline">\(O(n^{2})\)</span>. Futhermore, if <span class="math inline">\(g\)</span> is even the cycle we find will actually be of length <span class="math inline">\(g\)</span>.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> Algorithm: BFS-Cycle out of every vertex. Run time: <span class="math inline">\(O(n^{2})\)</span>.</p>
</div>
<h3 id="exact-algorithm-for-girth-in-nomega-time">Exact Algorithm for Girth in <span class="math inline">\(n^{\omega}\)</span> time</h3>
<div class="thm envbox">
<p><strong>Theorem.</strong> Exact Algorithm for Girth in <span class="math inline">\(n^{\omega}\)</span> time.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> First run the additive <span class="math inline">\(1\)</span>-approximation.</p>
<p>If it outputs a cycle of odd length we know it is equal to the girth. Else, call the length of the ouput cycle <span class="math inline">\(2\ell\)</span>. The girth is either <span class="math inline">\(2\ell\)</span> or <span class="math inline">\(2\ell-1\)</span>.</p>
<p>So, now we would just like to determine whether <span class="math inline">\(G\)</span> has a cycle of length <span class="math inline">\(2\ell-1\)</span>. At the beginning of this blog post we showed how to solve this with <span class="math inline">\(2\ell-2\)</span> matrix multiplications. But that’s not going to cut it here, we don’t really have a bound on <span class="math inline">\(\ell\)</span>.</p>
<p>Here’s how we construct a triangle-detection instance: Make a new graph <span class="math inline">\(G&#39;\)</span>. Place <span class="math inline">\(G\)</span> in <span class="math inline">\(G&#39;\)</span>. Then create copies of the vertices. Connect <span class="math inline">\(v\in V(G)\)</span> and copy the copy <span class="math inline">\(w&#39;\)</span> of <span class="math inline">\(w\in V(G)\)</span> if <span class="math inline">\(dist(v, w)=\ell-1\)</span>. We know this distance because of our BFS-ing.</p>
<p><span class="math inline">\(G&#39;\)</span> has a triangle iff <span class="math inline">\(G\)</span> has an <span class="math inline">\((2\ell-1)\)</span>-cycle. <img src="src/images/ink_img002.png" alt="ink_img002" /></p>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> <span class="math inline">\(\widetilde{O}(n^{3}/m)\)</span> time <span class="math inline">\(+3\)</span> additive girth approx.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong></p>
<ul>
<li>case 1: graph has <span class="math inline">\(O(n\log n)\)</span> edges: just give up and do a quadratic time algorithm.</li>
<li>case 2: graph has enough edges that we can find a good enough cycle via super-saturation: then just do that</li>
<li>case 3: graph is reasonably sparse, but not crazy sparse.
<ul>
<li>case 3.1: assume that all vertices on the cycle have degree at most <span class="math inline">\(n^{1/k}\)</span>.
<ul>
<li>BFS-cycle for <span class="math inline">\(k-1\)</span> levels, only visiting low degree vertices.</li>
</ul></li>
<li>case 3.2: there is a high degree vertex on the cycle. sample <span class="math inline">\(n/H\)</span> vertices. <em>this won’t necessarily hit a high degree vertex, but should at least hit a neighbor of a high degree vertex</em>. So we could do a <span class="math inline">\(+3\)</span> approx this way. Very few vertices we need to BFS out of here.</li>
</ul></li>
</ul>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong></p>
<ul>
<li>“Finding and Counting Given Length Cycles” Alon Yuster Zwick:</li>
<li><span class="math inline">\(m^{4/3}\)</span> algorithm for <span class="math inline">\(C_4\)</span>’s</li>
<li><span class="math inline">\(m^{13/8}\)</span> algorithm for <span class="math inline">\(C_6\)</span>’s</li>
<li>Count number of <span class="math inline">\(C_k\)</span>’s for <span class="math inline">\(k\le 7\)</span> in <span class="math inline">\(n^{\omega}\)</span> time. Unlikely to be possible for <span class="math inline">\(C_8\)</span>’s because <span class="math inline">\(K_4\)</span>’s are harder than <span class="math inline">\(K_3\)</span>’s.</li>
</ul>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> Every connected <span class="math inline">\(n\)</span> vertex graph with <span class="math inline">\(kn\)</span> edges has a <span class="math inline">\(k\)</span>-edge path (not necessarily induced) emenating from every vertex.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> We prove this by induction on <span class="math inline">\(k.\)</span> For <span class="math inline">\(k=1\)</span>, the base case, this is quite clear. For <span class="math inline">\(k&gt;1\)</span> we induct on <span class="math inline">\(n\)</span>. Let <span class="math inline">\(G\)</span> be an <span class="math inline">\(n+1\)</span> vertex graph with at least <span class="math inline">\(k(n+1)\)</span> edges.</p>
<p>Deleting any vertex may disconnect the graph into several connected components <span class="math inline">\(V_1,V_2,\ldots,V_\ell\)</span>. However, we claim that at least one of these connected components has average degree at least <span class="math inline">\(k-1\)</span>. You can check this. So to find the desired path, delete your vertex and then recursively find a <span class="math inline">\(k-1\)</span> path in the connected component with highest average degree.</p>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> Any graph with more than like <span class="math inline">\(200kn^{1+1/k}\)</span> edges is super-saturated with <span class="math inline">\(2k\)</span> cycles. I.e., we can find <span class="math inline">\(2k\)</span>-cycles in such a graph super easily.</p>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> There is a <span class="math inline">\(m^{2k/(k+1)}\)</span> time algo for finding a <span class="math inline">\(2k\)</span>-cycle in a <span class="math inline">\(m\)</span>-edge graph, if one exists.</p>
</div>
<h2 id="cutting-edge-approximations">cutting-edge approximations</h2>
<div class="rmk envbox">
<p><strong>Remark.</strong> In “New Subquadratic Approximation Algorithms for the Girth” Knudsen talks about Virginia and Roditty’s paper. He observes that her algorithm outputs a cycle of size <span class="math inline">\(2\left\lceil g/2 \right\rceil + 2\left\lceil g/4 \right\rceil\)</span> when the girth is <span class="math inline">\(g\)</span>. So technically for <span class="math inline">\(g=3\)</span> this is a <span class="math inline">\(2\)</span>-approx. But for larger values of <span class="math inline">\(g\)</span> it is essentially a <span class="math inline">\(1.5\)</span>-approx. And her algo is indeed <span class="math inline">\(n^{5/3}\)</span>.</p>
<p>Note: Knudsen gives a sub-quadratic algorithm that, if the girth is <span class="math inline">\(g\)</span>, returns a cycle with size at most <span class="math display">\[2\left\lceil g/2 \right\rceil+2\left\lceil \frac{g}{2(k-1)} \right\rceil\le (1+\varepsilon)g + 3,\]</span> for suitably large <span class="math inline">\(k\)</span>, although the run time is of course <span class="math inline">\(n^{2-1/k}\)</span>.</p>
<p>So I feel like the barrier to an <span class="math inline">\(o(n^{2})\)</span> <span class="math inline">\((2-\varepsilon)\)</span>-approx is really “given a graph with girth <span class="math inline">\(3\)</span>, can you find any of a triangle, a square, or a pentagon in subquadratic time?”</p>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> There is an algorithm that, given an <span class="math inline">\(n\)</span>-vertex graph <span class="math inline">\(G\)</span> with girth <span class="math inline">\(g\ge 3\)</span> outputs a cycle of length at most <span class="math display">\[2\left\lceil g/2 \right\rceil+2\left\lceil g/4 \right\rceil\le 2g,\]</span> in running time <span class="math inline">\(n^{5/3}\)</span>.</p>
</div>
<hr />
<div class="pf envbox">
<p><strong>Proof.</strong> <strong>CAUTION</strong> I have not been especially careful with the floors and ceilings in this proof. They are really important if you care about small <span class="math inline">\(g\)</span>! Beware.</p>
<p>Let <span class="math inline">\(C\)</span> be a length <span class="math inline">\(g\)</span> cycle in <span class="math inline">\(G\)</span>. Call a ball <strong>huge</strong> if it has size larger than <span class="math inline">\(n^{1/3}\)</span>.</p>
<p><strong>Case 1:</strong> Some vertex <span class="math inline">\(v\in C\)</span> has a huge <span class="math inline">\(t\)</span>-radius ball, for some <span class="math inline">\(t\le \left\lceil g/4 \right\rceil\)</span>. Then, if we randomly sample a subset <span class="math inline">\(S\)</span> of size <span class="math inline">\(n^{2/3}\log n\)</span> we intersect with <span class="math inline">\(B\)</span> with high probability. Imagine we ran BFS-cycle out of <span class="math inline">\(y\in B\)</span>. Then we would find a cycle of length at most <span class="math inline">\(g+2t \le 2g\)</span>. So what we do is run BFS-cycle out of all the points in <span class="math inline">\(S\)</span>. The cost of this is <span class="math inline">\(n^{2/3} \cdot n\le n^{5/3}\)</span>.</p>
<p><strong>Case 2:</strong> No vertices on the cycle have huge <span class="math inline">\(\left\lceil g/4 \right\rceil\)</span>-radius balls. Sort the vertices in the graph as <span class="math inline">\(v_1,v_2,\ldots, v_n\)</span> based on how fast their ball gets huge, i.e., the smallest <span class="math inline">\(k\)</span> such that their radius-<span class="math inline">\(k\)</span> ball is huge. In particular, make it so that <span class="math inline">\(v_1\)</span>’s ball becomes huge the slowest and <span class="math inline">\(v_n\)</span>’s ball becomes huge the fastest. Let <span class="math inline">\(H_k\)</span> denote the induced subgraph on <span class="math inline">\(v_1,v_2,\ldots, v_k\)</span>.</p>
<p>We do a BFS-Cycle from vertex <span class="math inline">\(k\)</span> in <span class="math inline">\(H_k\)</span> for each <span class="math inline">\(k\)</span>, except we stop once we have visited <span class="math inline">\(n^{2/3}\)</span> vertices. Let <span class="math inline">\(k_0\)</span> be the first index when all vertices of <span class="math inline">\(C\)</span> are contained in <span class="math inline">\(H_{k_0}\)</span>. We claim that doing this limited BFS in <span class="math inline">\(H_{k_0}\)</span> will find a cycle of length at most <span class="math inline">\(2g\)</span>.</p>
<p>Note that all vertices <span class="math inline">\(v\in H_{k_0}\)</span> satisfy <span class="math inline">\(|B(v, \left\lceil g/4 \right\rceil)| \le n^{1/3}\)</span> and thus <span class="math inline">\(|B(v, 2\left\lceil g/4 \right\rceil)|\le n^{2/3}\)</span>. Thus the BFS-cycle out of <span class="math inline">\(k_0\)</span> will successfully find a cycle of length like at most <span class="math inline">\(4\left\lceil g/4 \right\rceil+1\)</span> ish.</p>
<p>The run time of doing this is going to be <span class="math inline">\(n\cdot n^{2/3}\le n^{5/3}\)</span>.</p>
</div>
<div class="rmk envbox">
<p><strong>Remark.</strong> Virginia gives a somewhat different proof of this in her lecture notes. I’m writing it down too so that I’ll maybe understand it.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong></p>
<p>Let <span class="math inline">\(T_v\)</span> denote the result of BFS-ing out of <span class="math inline">\(v\)</span> until we get <span class="math inline">\(n^{1/3}\)</span> vertices in the tree.</p>
<p>She also starts by BFS-ing out of an <span class="math inline">\((n^{1/3}\log n)\)</span>-sized random set. (Basically. But she also checks that her random set intersects with all the <span class="math inline">\(T_v\)</span>’s. Presumably this happens with high probability? so not sure why she’s checking it.) This handles the case that some vertex in the cycle has a very large <span class="math inline">\(\left\lfloor g/4 \right\rfloor\)</span>-neighborhood.</p>
<p>But she handles the other case a bit differently from Knudsen. Case 2: Each <span class="math inline">\(v\in C\)</span> has a <span class="math inline">\(\left\lfloor g/4 \right\rfloor\)</span> ball of size at most <span class="math inline">\(n^{1/3}\)</span>. In this case we will compute the girth <em>exactly</em>.</p>
<p>Here’s the algorithm:</p>
<ul>
<li>for each <span class="math inline">\(v\)</span>
<ul>
<li>for each pair <span class="math inline">\(x,y \in T_v\)</span>
<ul>
<li>Insert <span class="math inline">\(v, d_{T_v}(x,y), p_{T_v}(x,y)\)</span> into <span class="math inline">\(Q_{x,y}\)</span></li>
</ul></li>
</ul></li>
<li>For each <span class="math inline">\(x,y\)</span> where <span class="math inline">\(Q_{x,y}\)</span> is non-empty:
<ul>
<li>Sort the values in <span class="math inline">\(Q_{x,y}\)</span>’s by distance.</li>
<li>Find <span class="math inline">\(u,v\)</span> such that <span class="math inline">\(d_{T_v}(x,y) + d_{T_u}(x,y)\)</span> is minimized</li>
<li>consider the cycle determined by <span class="math inline">\(x,y,u,v\)</span> as defining the quarters.</li>
</ul></li>
</ul>
</div>
<hr />
<div class="thm envbox">
<p><strong>Theorem.</strong> (Due to Knudsen et al, also from the paper “New Subquadratic Approximation Algorithms for the Girth”.)</p>
<p>There is a (multiplicative) <span class="math inline">\(\mathcal{O}(1)\)</span>-approx for girth with running time <span class="math inline">\(n^{1+1/k}\)</span> for any constant <span class="math inline">\(k\)</span>.</p>
</div>
<div class="pf envbox">
<p><strong>Proof.</strong> We present it for <span class="math inline">\(k=5\)</span> for simplicity.</p>
<p>We are going to give a <span class="math inline">\(31\)</span>-approximation or something.</p>
<p>Do each of the following things:</p>
<ul>
<li>Sample a set of <span class="math inline">\(n\)</span> vertices, BFS-Cycle for <span class="math inline">\(n^{1/5}\)</span> steps out of each of them.</li>
<li>Sample a set of <span class="math inline">\(n^{4/5}\log n\)</span> vertices, BFS-cycle for <span class="math inline">\(n^{2/5}\)</span> steps out of each of these vertices.</li>
<li>Sample a set of <span class="math inline">\(n^{3/5}\log n\)</span> vertices, BFS-cycle for <span class="math inline">\(n^{3/5}\)</span> steps out of each of these vertices.</li>
<li>Sample a set of <span class="math inline">\(n^{2/5}\log n\)</span> vertices, BFS-cycle for <span class="math inline">\(n^{4/5}\)</span> steps out of each of these vertices.</li>
<li>Sample a set of <span class="math inline">\(n^{1/5}\log n\)</span> vertices, BFS-cycle for <span class="math inline">\(n^{5/5}\)</span> steps out of each of these vertices.</li>
</ul>
<p>Let <span class="math inline">\(C\)</span> be a minimum length cycle.</p>
<p>Let <span class="math inline">\(r_0\)</span> be the minimum <span class="math inline">\(r&gt;0\)</span> such that <span class="math inline">\(|B(C, \left\lceil g/2 \right\rceil(2^{r}-1))| \le n^{r/5}\)</span>. Then we have that <span class="math inline">\(|B(C, \left\lceil g/2 \right\rceil(2^{r_0-1}-1))| &gt; n^{(r_0-1)/5}\)</span>.</p>
<p>We claim that we will find a pretty short cycle when we run the <span class="math inline">\(r_0\)</span>-th itteration of our for-loop.</p>
<p>By a calculation we find that we will, with high probability, get some vertex <span class="math inline">\(u \in B(C, \left\lceil g/2 \right\rceil(2^{r_0-1}-1))\)</span> in the set of size <span class="math inline">\(n^{\frac{6-r_0}{5})} \log n\)</span> that we sample. Then if we BFS-cycle out of this dude we get the desired short cycle.</p>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> In fact, in more recent work “Algorithmic trade-offs for girth approximation in undirected graphs” Virginia shows how to get an almost <span class="math inline">\(k\)</span>-approximation in <span class="math inline">\(n^{1+1/k}\)</span> time. (exponentially better than Knudsen’s result above!) More precisely, it outputs a cycle of length at most <span class="math inline">\(2k\left\lceil g/2 \right\rceil\)</span> where <span class="math inline">\(g\)</span> is the girth of <span class="math inline">\(G\)</span>.</p>
<p>There is also a version of this that gives a slightly different guarantee if the girth <span class="math inline">\(g\)</span> is odd: it outputs a cycle of length at most <span class="math inline">\(2k\left\lfloor g/2 \right\rfloor+2\)</span> in time <span class="math inline">\(O(m(n^{2}/m)^{1/k}).\)</span></p>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> In “Algorithmic trade-offs for girth approximation in undirected graphs” Virginia gives an algorithm that takes as input parameters <span class="math inline">\(g_0,k\)</span> and has the following guarantee:</p>
<ul>
<li>Either output a cycle of length <span class="math inline">\(\le 2k\)</span> or fail. This algo runs in time <span class="math inline">\(O(\min(m, n^{1+1/k}))\)</span>.</li>
<li>If fail, we can run another algorithm that will either:
<ul>
<li>output a shortest cycle OR</li>
<li>determine that the girth is larger than <span class="math inline">\(g_0\)</span></li>
</ul></li>
<li><span class="math inline">\(O(n^{1+2/k})\)</span> if <span class="math inline">\(g_0\in \left\{ 3,4\right\}\)</span>. Can also do <span class="math inline">\(O(m^{1+1/(k+1)})\)</span> here.</li>
<li><span class="math inline">\(O(n^{1+3/k})\)</span> if <span class="math inline">\(g_0=5\)</span>. Can also do <span class="math inline">\(O(m^{1+2/(k+1)})\)</span> here.</li>
<li>something some-what similar for <span class="math inline">\(g=6\)</span>.</li>
</ul>
<p>For instance, if <span class="math inline">\(g_0=3\)</span> and <span class="math inline">\(k=3\)</span> we get: Either a cycle of length <span class="math inline">\(\le 6\)</span> or a shortest cycle OR the algorithm declares the graph to be triangle free. All in running time <span class="math inline">\(n^{5/3}\)</span>.</p>
</div>
<div class="thm envbox">
<p><strong>Theorem.</strong> <span class="math inline">\(n^{1+1/(2-\varepsilon)}\)</span> algo gives a cycle of length at most <span class="math inline">\((2-\varepsilon)g+4\)</span> for <span class="math inline">\(g\le \lg^2 n\)</span> and <span class="math inline">\((2-\varepsilon/2)g+3\)</span> else. This is like a continuous extension of Knudsen’s similar result.</p>
</div>
<hr />
<p>There is also some work on weighted graphs, e.g., “Improved girth approximation in weighted undirected graphs”.</p>
<p>And even work on directed graphs.</p>
<hr />
<h2 id="list-of-things-to-look-up">list of things to look up</h2>
<p>relevant graph parameters that we could do case-work on: - degeneracy - capped walls? - arboricity</p>

      </div>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full"></script>
    <script src="../../formatting/scrolling-nav.js"></script>

    <script charset="utf-8">
        var pres = document.querySelectorAll("pre>code");
        for (var i = 0; i < pres.length; i++) {
            hljs.highlightBlock(pres[i]);
        }
    </script>

    <div id="disqus_thread"></div>
    <script>
      /**
      *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
      *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
      /*
      var disqus_config = function () {
      this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
      };
      */
      (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://awestovergithubioskyspace.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    <script id="dsq-count-scr" src="//awestovergithubioskyspace.disqus.com/count.js" async></script>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-P9YVJX8W9R"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-P9YVJX8W9R');
</script>

  </body>
</html>
