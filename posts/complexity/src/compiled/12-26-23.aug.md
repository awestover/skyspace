\newcommand{\one}{\mathbbm{1}}
\newcommand{\bigO}{\mathcal{O}}
\DeclareMathOperator{\E}{\mathbb{E}}
\DeclareMathOperator{\Var}{\text{Var}}
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\Id}{Id}
\DeclareMathOperator{\img}{Img}
\DeclareMathOperator{\polylog}{\text{polylog}}
\DeclareMathOperator{\poly}{\text{poly}}
\newcommand{\st}{\text{ such that }}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\interior}[1]{ {\kern0pt#1}^{\mathrm{o}} }
\newcommand{\mb}{\mathbf}
\newcommand{\partition}{\vdash}
\newcommand{\x}{\mathbf{x}}
\newcommand{\y}{\mathbf{y}}
\newcommand{\z}{\mathbf{z}}
\newcommand{\eps}{\varepsilon}
\renewcommand{\d}{\mathrm{d}}
\renewcommand{\Re}{\mathrm{Re}}
\renewcommand{\Im}{\mathrm{Im}}

\newcommand{\setof}[2]{\left\{ #1\; : \;#2 \right\}}
\newcommand{\set}[1]{\left\{ #1\right\}}

\newcommand{\R}{\mathbb{R}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\contr}{\[ \Rightarrow\!\Leftarrow \]}
\newcommand{\defeq}{\vcentcolon=}
\newcommand{\eqdef}{=\vcentcolon}

\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\paren}[1]{\left( #1 \right)}
\newcommand{\ang}[1]{\langle #1 \rangle}
\newcommand{\abs}[1]{\left| #1 \right|}


# reductions between square or triangle and k-cycle

Henceforth $C_4$ will be refered to as a "square" sometimes.

Proof from Appendix of Aboud FOCS22. 
"Hardness of approximation in P via short-cycle removal"

They prove two interesting theorems:

<div class="thm envbox">**Theorem.**
- For any $k\in \N$ there is an $O(m)$ time algorithm that, on 
    an $m$-edge graph $G$ produces a graph $G^{\star}$ whose
    $4k$-cycles are in bijection with $G$'s $4$-cycles.
- For any $k\ge 3$ not a power of $2$, there is an $O(m)$ time
    algorithm that, on an $m$-edge graph $G$ produces a
    graph $G^{\star}$ such that $G$'s triangles are in bijection
    with $G^{\star}$'s $k$-cycles.
</div>

<div class="cor envbox">**Corollary.**

- If $k$-cycle can be solved in $m^{\alpha}$ time for any
$k,\alpha$, then for at least one of $k_0\in \{3,4\}$ we can
solve $k$-cycle detection in $m^{\alpha}$ time.
- If there is an algorithm that with $O(m^{\alpha})$
    preprocessing lists $k$-cycles with $m^{o(1)}$ delay, then
    there is also such an algorithm for at least one of triangle
    / square enumeration.
</div>

<div class="cor envbox">**Corollary.**
The result of Jin Xu STOC23 implies that there is no
$m^{4/3-o(1)}$ preprocessing followed by tiny delays algorithm
for $2k$-cycle listing.
But this is of course kind of weaker than what we believe to be
the truth.
</div>

ok now lets see some proofs:

<img src='../../images/blob.png' width='25%'>

> "pfs vg!" -Blobby

<div class="lem envbox">**Lemma.**
Let $r\mid k$.
$G \to G'$, such that $C_r\leftrightarrow C_k$
</div>
<div class="pf envbox">**Proof.**
Subdivide the edges. i.e., replace the edges with paths of length
$k/r$.
</div>

<div class="lem envbox">**Lemma.**
Let $k$ be odd. 
There is an $O(m)$ time algorithm that takes a tripartite graph $G$ and converts it into $G^{\star}$ so that triangles in $G$ are in bijection with $k$-cycles in $G^{\star}$.
</div>
<div class="pf envbox">**Proof.**
Exchange each $B\times C$ edge for a path of length $k-2$, i.e.,
subdivide those edges.

It is clear that triangles get converted into $k$-cycles.
To see the other direction it is helpful to partition the vertex
set into $A,B,C, D_1,D_2,\ldots, D_{k-3}$ where $D_i$ is the
vertices which are  $i$ steps along a $B\to C$ path.

Observe that if we delete any of these parts the graph becomes
bipartite, and then we could certainly not find a $k$-cycle in
it. Hence every $k$-cycle must actually use one of the $B \times
C$ path / edge things and thus actually corresponds to a triangle
in the original graph.

</div>

<div class="rmk envbox">**Remark.**
These both have the unfortunate property of resuling in
graphs with way too many vertices. 
</div>


# square listing

"Listing 4-Cycles" Abboud et al:
https://arxiv.org/pdf/2211.10022.pdf

<div class="prop envbox">**Proposition.**
You can list squares in $O(n^{2}+t)$ time, where $t$ is number
of squares.
</div>
<div class="pf envbox">**Proof.**
Do a 2 step BFS out of every vertex. For each pair $u,v$ make a
list of the paths of length $2$ between $u,v$.

Then itterate over $u,v$ and itterate over pairs of paths of
length $2$ between $u, v$: each of these is a four-cycle. 
</div>

<div class="rmk envbox">**Remark.**
Now we enter sparse land. In sparse land we always assume wlog
that $n\le O(m)$.
</div>

<div class="thm envbox">**Theorem.**
You can list squares in $\widetilde{O}(m^{4/3}+t)$ time, where
$t$ is number of squares.
</div>
<div class="pf envbox">**Proof.**
Let $L$ be the set of low-degree vertices, i.e., vertices with
degree smaller than $m^{1/3}$. Let $H$ be the high degree
vertices. 

We break it into a few cases:

- 2-paths wtih an L at the middle
- 2-paths consisting solely of H vertices
- "LHH" 2-paths. these ones are more tricky. But we only have to
    list half of them. So they direct the graph in an interesting
    way.

</div>

<div class="lem envbox">**Lemma.**
You can list 2-paths with an L in the middle in $O(m^{4/3})$ time.
</div>
<div class="pf envbox">**Proof.**
Itterate over edges, if the edge has a low-degree endpoint
itterate over that endpoint's neighbors.
Time $O(m^{4/3})$
</div>

<div class="lem envbox">**Lemma.**
You can list 2-paths only involving H vertices in $O(m^{4/3}+t)$
time.
</div>
<div class="pf envbox">**Proof.**
At most $m^{4/3}$ pairs of high deg vertices. 
Let $G'$ be the graph where we have removed low degree vertices.
This can be computed in time $O(m)$.
Now we do a 2-step BFS out of each vertex in $G'$.
You have to pay for the first 2-path you list between each pair of high degree vertices. 
After the first one though the rest get charged to $4$-cycles. 
</div>

<div class="thm envbox">**Theorem.**
The hard case: LHH.
</div>

<div class="lem envbox">**Lemma.**
Any graph with $n$ vertices and average degree $d$ has  $\Omega(d^{4}-n^{2})$ 4-cycles.
</div>
<div class="pf envbox">**Proof.**
$\lambda_1(G) \ge d^{4}$.
The number of walks of length 4 is $tr(A^{4})  \ge \lambda_1(G)$.
The number of 4-walks is equal to the number of 2-paths:
![ink_img001](src/images/ink_img001.png)

The number of $2$-paths is simply:
$$\sum_{uv} codeg(u,v) \le O(n^{2} + \# C_4).$$

In summary:

$$\# C_4 + \# P_2 \ge d^{4}$$
so

$$\# C_4 \ge \Omega(d^{4}-n^{2}).$$

</div>

<div class="lem envbox">**Lemma.**
Direct the edges from low degree vertex to high degree vertex
(breaking ties arbitrarily).

There exists a partition $H = A\sqcup B$ of high degree vertices
so that 

1. The partition captures most of the $L\to H\to H$ paths. I.e.,
   the number of  $L\to A\to B$ paths is at least an
   $\Omega(1/\log^{2} n)$-fraction of all of the $L\to H\to H$
   paths.
2. The vertices in $A$ all have about the same number of $L$
   neighbors (up to multiplicative factor of $2$) and about the
   same number of $B$ neighbors.
3. All vertices in $B$ have an $A$ dude pointing at them.
</div>
<div class="pf envbox">**Proof.**

Start by selecting each high-degree vertex to join $A$ with probability $1/2$.
This kills $3/4$ of  the $L\to H\to H$ paths on average.
Now bucket the nodes based on  $\floor{\log_2 \cdot}$ in arrows
from L and out arrows to B. 

![ink_img002](src/images/ink_img002.png)

</div>

<div class="thm envbox">**Theorem.**
Let $P$ be the number of $L\to H \to H$ paths.
If $P  > 100m^{4/3}\log^{2} n$ then there are at least
$P/(100\log^{2 n})$ $4$-cycles.
</div>
<div class="pf envbox">**Proof.**
Combine the lemmas.
</div>

<div class="thm envbox">**Theorem.**
We can list 4-cycles in $\widetilde{O}(m^{4/3}+t)$ time.
</div>
<div class="pf envbox">**Proof.**
Combine the lemmas.
</div>

TODO: read "[AYZ95] Noga Alon, Raphael Yuster, and Uri Zwick. Color-coding. J. ACM, 42(4):844â€“856, 1995." especially section 4 "perfect hashing"

TODO: read "Listing 6-Cycles": Jin Williams, Zhou 
extends this stuff to work for 6-cycles.

